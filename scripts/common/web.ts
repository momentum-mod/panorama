/**
 * @file
 * !! Do not edit this file directly! This is generated from contents of the web
 * !! repository. If you really need to change something, make the change in the
 * !! web repository and run `npm run fetch-web`.
 *
 * Collection of constant values and types shared between the
 * https://github.com/momentum-mod/website monorepo and Panorama, containing:
 * - Types: TypeScript types and interfaces, primarily for modeling the DTOs
 *   (data transfer objects) returned by the backend.
 *   The C++ equivalents of these live in mom_api_models.h.
 * 	 See https://staging-api.momentum-mod.org/docs Schemas section, for
 * 	 detailed descriptions of every model/DTO.
 * - Enums: TypeScript enums for everything the backend uses.
 *   The C++ equivalents of these mostly live in mom_api_shareddefs.h.
 * - Maps: Readonly KV maps, usually associating enum values with extra data,
 *   e.g. gamemodes to their names, prefixes, icons etc...
 *   We use Maps instead of Objects since JavaScript object keys can only be
 *   strings or symbols, and most of our enum values are numbers.
 *
 * These are fetched from https://github.com/momentum-mod/website/tree/main/libs/constants
 * to maintain a single source of truth across our TypeScript projects. Things
 * unique to Panorama don't need to live here, they can be defined in other
 * files in this codebase.
 */
/* eslint-disable */

import { arrayToVector, dot2D, isCCW, magnitude2D, subtractVector2D } from 'util/math';

// Stub any broswer/node types we don't actually use:
type File = never;

export const STEAM_APPIDS = [669270, 1802710];

export function approvedBspPath(key: string | number): string {
	return `maps/${key}.bsp`;
}

export function approvedVmfsPath(key: string | number): string {
	return `maps/${key}_VMFs.zip`;
}

export function submissionBspPath(key: string | number): string {
	return `submissions/${key}.bsp`;
}

export function submissionVmfsPath(key: string | number): string {
	return `submissions/${key}_VMFs.zip`;
}

export function imgSmallPath(key: string): string {
	return `img/${key}-small.jpg`;
}

export function imgMediumPath(key: string): string {
	return `img/${key}-medium.jpg`;
}

export function imgLargePath(key: string): string {
	return `img/${key}-large.jpg`;
}

export function imgXlPath(key: string): string {
	return `img/${key}-xl.jpg`;
}

export function runPath(key: string | number | bigint): string {
	return `runs/${key}`;
}

export function mapListPath(type: FlatMapList, version: string | number): string {
	return `maplist/${type === FlatMapList.APPROVED ? 'approved' : 'submissions'}/${version}.dat`;
}

export function mapListDir(type: FlatMapList) {
	return type === FlatMapList.APPROVED ? 'maplist/approved/' : 'maplist/submissions/';
}

export function mapReviewAssetPath(key: string): string {
	return `mapreview/${key}`;
}

export const JWT_WEB_EXPIRY_TIME = '15m';
export const JWT_GAME_EXPIRY_TIME = '24h';
export const JWT_REFRESH_EXPIRY_TIME = '5d';

export const MAX_DAILY_REPORTS = 5;
export const MAX_MAP_IMAGES = 5;
export const MAX_BSP_SIZE = 300_000_000;
export const MAX_VMF_SIZE = 100_000_000;
export const MAX_MAP_IMAGE_SIZE = 10_000_000;
export const MAP_IMAGE_WIDTH = 2560;
export const MAP_IMAGE_HEIGHT = 1440;
export const MAX_CREDIT_DESCRIPTION_LENGTH = 64;
export const MAX_CHANGELOG_LENGTH = 1500;
export const MAX_REVIEW_LENGTH = 5000;
export const MAX_REVIEW_IMAGES = 20;
export const MAX_REVIEW_COMMENT_LENGTH = 1000;
export const MAX_TEST_INVITES = 20;
export const MIN_PUBLIC_TESTING_DURATION = 7 * 24 * 60 * 60 * 1000;
export const MAX_CREDITS_EXCEPT_TESTERS = 20;
export const MAX_BIO_LENGTH = 2000;
export const MIN_MAP_DESCRIPTION_LENGTH = 30; // Fuck you, make an effort
export const MAX_MAP_DESCRIPTION_LENGTH = 1500;
export const MIN_MAP_NAME_LENGTH = 3;
export const MAX_MAP_NAME_LENGTH = 32; // Seems high but this is actually a constant in engine.
export const MAX_MAP_SUGGESTION_COMMENT_LENGTH = 500;
export const PRE_SIGNED_URL_EXPIRE_TIME = 5 * 60;

// Very permissive regex for whenever exact criteria not avoilable online
const defaultRegex = /^[\w-]{3,40}$/;

export const SocialsData: Readonly<
	Record<keyof Socials, { icon: string; regex: RegExp; example: string; url: string }>
> = {
	Discord: {
		icon: 'discord',
		regex: /^[\w-]{2,32}$/,
		example: 'username',
		url: 'discordapp.com/users'
	},
	Twitch: {
		icon: 'twitch',
		regex: /^[\w-]{4,25}$/,
		example: 'username',
		url: 'twitch.tv'
	},
	YouTube: {
		icon: 'youtube',
		regex: /^@[\w-]{3,30}$/,
		example: '@username',
		url: 'youtube.com'
	},
	Github: {
		icon: 'github',
		regex: /^[\w-]{2,39}$/,
		example: 'username',
		url: 'github.com'
	},
	Twitter: {
		icon: 'twitter',
		regex: /^[\w-]{2,15}$/,
		example: 'username',
		url: 'twitter.com'
	},
	Mastodon: {
		icon: 'mastodon',
		regex: /^(?:@[\w-]+){2}\.[\w-]+$/,
		example: '@user@instance',
		// For any Mastodon instance `foo`, user `user`, user's instance `instance`,
		// https://foo/@user@instance redirects to https://instance/@user.
		// So just using the official instance works for everything.
		url: 'mastodon.social'
	},
	LinkedIn: {
		icon: 'linkedin',
		regex: defaultRegex,
		example: 'firstname-lastname-12345',
		url: 'linkedin.com/in'
	},
	Instagram: {
		icon: 'instagram',
		regex: defaultRegex, // Sequential underscores are allowed
		example: 'username',
		url: 'instagram.com'
	},
	Spotify: {
		icon: 'spotify',
		regex: defaultRegex, // Just randomly generated alphanumeric
		example: '21ahtj33ps3kiiet4sqq4pnra',
		url: 'open.spotify.com/user'
	},
	Patreon: {
		icon: 'patreon',
		regex: defaultRegex,
		example: 'username',
		url: 'patreon.com'
	},
	'Ko-fi': {
		icon: 'kofi',
		regex: defaultRegex,
		example: 'username',
		url: 'ko-fi.com'
	},
	Paypal: {
		icon: 'paypal',
		// Either email or @whatever
		regex: /^@[\w-]{3,30}$/,
		example: 'username (Must be a paypal.me profile)',
		url: 'paypal.me'
	}
};

// This is the specific key Steam uses for all missing avatars.
// They even kept it when migrating to Cloudflare!
export const STEAM_MISSING_AVATAR = 'fef49e7fa7e1997310d705b2a6158ff8dc1cdfeb';
export const STEAM_MISSING_AVATAR_URL = `https://avatars.cloudflare.steamstatic.com/${STEAM_MISSING_AVATAR}_full.jpg`;

export enum ActivityType {
	ALL = 0,
	MAP_UPLOADED = 1,
	MAP_APPROVED = 2,
	REVIEW_MADE = 3,
	PB_ACHIEVED = 4,
	WR_ACHIEVED = 5,
	REPORT_FILED = 6,
	USER_JOINED = 7
}

export enum AdminActivityType {
	USER_UPDATE = 0,
	USER_CREATE_PLACEHOLDER = 1,
	USER_MERGE = 2,
	USER_DELETE = 3,
	MAP_UPDATE = 4,
	MAP_CONTENT_DELETE = 5,
	REPORT_UPDATE = 6,
	REPORT_RESOLVE = 7,
	REVIEW_DELETED = 8,
	REVIEW_COMMENT_DELETED = 9
}

export enum Ban {
	LEADERBOARDS = 0b00001,
	ALIAS = 0b00010,
	AVATAR = 0b00100,
	BIO = 0b01000,
	MAP_SUBMISSION = 0b10000
}

// All valid (officially assigned) ISO 3166-1 Alpha-2 codes, scraped from Wikipedia
export enum ISOCountryCode {
	AD = 'Andorra',
	AE = 'United Arab Emirates',
	AF = 'Afghanistan',
	AG = 'Antigua and Barbuda',
	AI = 'Anguilla',
	AL = 'Albania',
	AM = 'Armenia',
	AO = 'Angola',
	AQ = 'Antarctica',
	AR = 'Argentina',
	AS = 'American Samoa',
	AT = 'Austria',
	AU = 'Australia',
	AW = 'Aruba',
	AX = 'Åland Islands',
	AZ = 'Azerbaijan',
	BA = 'Bosnia and Herzegovina',
	BB = 'Barbados',
	BD = 'Bangladesh',
	BE = 'Belgium',
	BF = 'Burkina Faso',
	BG = 'Bulgaria',
	BH = 'Bahrain',
	BI = 'Burundi',
	BJ = 'Benin',
	BL = 'Saint Barthélemy',
	BM = 'Bermuda',
	BN = 'Brunei Darussalam',
	BO = 'Bolivia',
	BQ = 'Bonaire',
	BR = 'Brazil',
	BS = 'Bahamas',
	BT = 'Bhutan',
	BV = 'Bouvet Island',
	BW = 'Botswana',
	BY = 'Belarus',
	BZ = 'Belize',
	CA = 'Canada',
	CC = 'Cocos (Keeling) Islands',
	CD = 'Congo',
	CF = 'Central African Republic',
	 
	CG = 'Congo',
	CH = 'Switzerland',
	CI = 'Ivory Coast',
	CK = 'Cook Islands',
	CL = 'Chile',
	CM = 'Cameroon',
	CN = 'China',
	CO = 'Colombia',
	CR = 'Costa Rica',
	CU = 'Cuba',
	CV = 'Cabo Verde',
	CW = 'Curacao',
	CX = 'Christmas Island',
	CY = 'Cyprus',
	CZ = 'Czechia',
	DE = 'Germany',
	DJ = 'Djibouti',
	DK = 'Denmark',
	DM = 'Dominica',
	DO = 'Dominican Republic',
	DZ = 'Algeria',
	EC = 'Ecuador',
	EE = 'Estonia',
	EG = 'Egypt',
	EH = 'Western Sahara',
	ER = 'Eritrea',
	ES = 'Spain',
	ET = 'Ethiopia',
	FI = 'Finland',
	FJ = 'Fiji',
	FK = 'Falkland Islands (Malvinas)',
	FM = 'Federated States of Micronesia',
	FO = 'Faroe Islands',
	FR = 'France',
	GA = 'Gabon',
	GB = 'United Kingdom',
	GD = 'Grenada',
	GE = 'Georgia',
	GF = 'French Guiana',
	GG = 'Guernsey',
	GH = 'Ghana',
	GI = 'Gibraltar',
	GL = 'Greenland',
	GM = 'Gambia',
	GN = 'Guinea',
	GP = 'Guadeloupe',
	GQ = 'Equatorial Guinea',
	GR = 'Greece',
	GS = 'South Georgia and the South Sandwich Islands',
	GT = 'Guatemala',
	GU = 'Guam',
	GW = 'Guinea-Bissau',
	GY = 'Guyana',
	HK = 'Hong Kong',
	HM = 'Heard Island and McDonald Islands',
	HN = 'Honduras',
	HR = 'Croatia',
	HT = 'Haiti',
	HU = 'Hungary',
	ID = 'Indonesia',
	IE = 'Ireland',
	IL = 'Israel',
	IM = 'Isle of Man',
	IN = 'India',
	IO = 'British Indian Ocean Territory',
	IQ = 'Iraq',
	IR = 'Islamic Republic of Iran',
	IS = 'Iceland',
	IT = 'Italy',
	JE = 'Jersey',
	JM = 'Jamaica',
	JO = 'Jordan',
	JP = 'Japan',
	KE = 'Kenya',
	KG = 'Kyrgyzstan',
	KH = 'Cambodia',
	KI = 'Kiribati',
	KM = 'Comoros',
	KN = 'Saint Kitts and Nevis',
	KP = "Democratic People's Republic of Korea",
	KR = 'Korea',
	KW = 'Kuwait',
	KY = 'Cayman Islands',
	KZ = 'Kazakhstan',
	LA = "Lao People's Democratic Republic",
	LB = 'Lebanon',
	LC = 'Saint Lucia',
	LI = 'Liechtenstein',
	LK = 'Sri Lanka',
	LR = 'Liberia',
	LS = 'Lesotho',
	LT = 'Lithuania',
	LU = 'Luxembourg',
	LV = 'Latvia',
	LY = 'Libya',
	MA = 'Morocco',
	MC = 'Monaco',
	MD = 'Moldova',
	ME = 'Montenegro',
	MF = 'Saint Martin',
	MG = 'Madagascar',
	MH = 'Marshall Islands',
	MK = 'North Macedonia',
	ML = 'Mali',
	MM = 'Myanmar',
	MN = 'Mongolia',
	MO = 'Macao',
	MP = 'Northern Mariana Islands',
	MQ = 'Martinique',
	MR = 'Mauritania',
	MS = 'Montserrat',
	MT = 'Malta',
	MU = 'Mauritius',
	MV = 'Maldives',
	MW = 'Malawi',
	MX = 'Mexico',
	MY = 'Malaysia',
	MZ = 'Mozambique',
	NA = 'Namibia',
	NC = 'New Caledonia',
	NE = 'Niger',
	NF = 'Norfolk Island',
	NG = 'Nigeria',
	NI = 'Nicaragua',
	NL = 'Netherlands',
	NO = 'Norway',
	NP = 'Nepal',
	NR = 'Nauru',
	NU = 'Niue',
	NZ = 'New Zealand',
	OM = 'Oman',
	PA = 'Panama',
	PE = 'Peru',
	PF = 'French Polynesia',
	PG = 'Papua New Guinea',
	PH = 'Philippines',
	PK = 'Pakistan',
	PL = 'Poland',
	PM = 'Saint Pierre and Miquelon',
	PN = 'Pitcairn',
	PR = 'Puerto Rico',
	PS = 'Palestine',
	PT = 'Portugal',
	PW = 'Palau',
	PY = 'Paraguay',
	QA = 'Qatar',
	RE = 'Réunion',
	RO = 'Romania',
	RS = 'Serbia',
	RU = 'Russian Federation',
	RW = 'Rwanda',
	SA = 'Saudi Arabia',
	SB = 'Solomon Islands',
	SC = 'Seychelles',
	SD = 'Sudan',
	SE = 'Sweden',
	SG = 'Singapore',
	SH = 'Saint Helena',
	SI = 'Slovenia',
	SJ = 'Svalbard and Jan Mayen',
	SK = 'Slovakia',
	SL = 'Sierra Leone',
	SM = 'San Marino',
	SN = 'Senegal',
	SO = 'Somalia',
	SR = 'Suriname',
	SS = 'South Sudan',
	ST = 'Sao Tome and Principe',
	SV = 'El Salvador',
	SX = 'Sint Maarten',
	SY = 'Syrian Arab Republic',
	SZ = 'Eswatini',
	TC = 'Turks and Caicos Islands',
	TD = 'Chad',
	TF = 'French Southern Territories',
	TG = 'Togo',
	TH = 'Thailand',
	TJ = 'Tajikistan',
	TK = 'Tokelau',
	TL = 'Timor-Leste',
	TM = 'Turkmenistan',
	TN = 'Tunisia',
	TO = 'Tonga',
	TR = 'Turkey',
	TT = 'Trinidad and Tobago',
	TV = 'Tuvalu',
	TW = 'Taiwan',
	TZ = 'Tanzania',
	UA = 'Ukraine',
	UG = 'Uganda',
	UM = 'United States Minor Outlying Islands',
	US = 'United States of America',
	UY = 'Uruguay',
	UZ = 'Uzbekistan',
	VA = 'Holy See',
	VC = 'Saint Vincent and the Grenadines',
	VE = 'Venezuela',
	VG = 'British Virgin Islands',
	VI = 'U.S. Virgin Islands',
	VN = 'Viet Nam',
	VU = 'Vanuatu',
	WF = 'Wallis and Futuna',
	WS = 'Samoa',
	YE = 'Yemen',
	YT = 'Mayotte',
	ZA = 'South Africa',
	ZM = 'Zambia',
	ZW = 'Zimbabwe'
}

export enum DefragModifiers {
	HASTE = 1 << 0,
	SLICK = 1 << 1,
	DAMAGEBOOST = 1 << 2,
	ROCKETS = 1 << 3,
	PLASMA = 1 << 4,
	BFG = 1 << 5
}

export enum FlatMapList {
	APPROVED = 'approved',
	SUBMISSION = 'submission'
}

/**
 * All the modes available in Momentum.
 */
export enum Gamemode {
	SURF = 1,
	BHOP = 2,
	BHOP_HL1 = 3,
	CLIMB_MOM = 4,
	CLIMB_KZT = 5,
	CLIMB_16 = 6,
	RJ = 7,
	SJ = 8,
	AHOP = 9,
	CONC = 10,
	DEFRAG_CPM = 11,
	DEFRAG_VQ3 = 12,
	DEFRAG_VTG = 13
}

/**
 * The outer categories that gamemodes are grouped into.
 */
export enum GamemodeCategory {
	SURF = 1,
	BHOP = 2,
	CLIMB = 3,
	RJ = 4,
	SJ = 5,
	AHOP = 6,
	CONC = 7,
	DEFRAG = 8
}

/**
 * All the image formats we support in different places.
 *
 * We could support more images if we really wanted, but WebP really isn't
 * that impressive vs mozjpeg jpegs, and we use mozjpeg to compress submitted
 * MapImage PNGs, so not much point bothering. Also fuck Google.
 */
export enum ImageType {
	JPG,
	PNG
}

// Enum is string based to make using as object keys easier
export enum KillswitchType {
	NEW_SIGNUPS = 'NEW_SIGNUPS',
	RUN_SUBMISSION = 'RUN_SUBMISSION',
	MAP_SUBMISSION = 'MAP_SUBMISSION',
	MAP_REVIEWS = 'MAP_REVIEWS'
}

export enum LeaderboardType {
	RANKED = 0,
	UNRANKED = 1,
	HIDDEN = 2,
	IN_SUBMISSION = 3
}

export enum MapCreditType {
	/* Contributed significant work to the map */
	AUTHOR = 0,
	/* Did minor work on the map */
	CONTRIBUTOR = 1,
	/* Tested the map during development, or submitted reviews during map
	 * submission testing phases */
	TESTER = 2,
	/* Any miscellaneous contributions, e.g. donations, encouragement etc. */
	SPECIAL_THANKS = 3
}

export enum MapStatus {
	/* Completed submission and is available to everyone */
	APPROVED = 0,
	/* Available in the Beta tab to users with an accepted MapTestingInvite */
	PRIVATE_TESTING = 1,
	/* Awaiting approval from a REVIEWER before it can be made public */
	CONTENT_APPROVAL = 2,
	/* Available to all users in the Beta tab*/
	PUBLIC_TESTING = 3,
	/* Awaiting final approval from a MODERATOR/ADMIN */
	FINAL_APPROVAL = 4,
	/* Anything that has been disabled for some reason, such as rejected map
  submissions, maps with critical bugs (that may often be fixed and re-enabled),
  maps with a DMCA claim, etc. */
	DISABLED = 5
}

export const CombinedMapStatuses = Object.freeze({
	IN_SUBMISSION: [
		MapStatus.PRIVATE_TESTING,
		MapStatus.PUBLIC_TESTING,
		MapStatus.CONTENT_APPROVAL,
		MapStatus.FINAL_APPROVAL
	]
});

export enum MapSubmissionType {
	ORIGINAL = 0,
	PORT = 1,
	SPECIAL = 2
}

export enum MapTestInviteState {
	UNREAD = 0,
	ACCEPTED = 1,
	DECLINED = 2
}

export enum ReportCategory {
	OTHER = 0,
	INAPPROPRIATE_CONTENT = 1,
	PLAGIARISM = 2,
	SPAM = 3
}

export enum ReportType {
	USER_PROFILE_REPORT = 0,
	MAP_REPORT = 1,
	MAP_COMMENT_REPORT = 2
}

export enum Role {
	ADMIN = 0b00000001,
	MODERATOR = 0b00000010,
	VERIFIED = 0b00000100,
	PLACEHOLDER = 0b00001000,
	DELETED = 0b00010000,
	REVIEWER = 0b00100000,
	MAPPER = 0b01000000,
	PORTER = 0b10000000
}

export const CombinedRoles = Object.freeze({
	MOD_OR_ADMIN: Role.MODERATOR | Role.ADMIN,
	REVIEWER_AND_ABOVE: Role.REVIEWER | Role.MODERATOR | Role.ADMIN,
	MAPPER_OR_PORTER: Role.MAPPER | Role.PORTER,
	MAPPER_AND_ABOVE: Role.MAPPER | Role.PORTER | Role.REVIEWER | Role.MODERATOR | Role.ADMIN
}); // These live in here as service logic and E2E need access.

export enum RunValidationErrorType {
	BAD_TIMESTAMPS,
	BAD_REPLAY_FILE,
	BAD_META,
	INVALID_STATS,
	OUT_OF_SYNC,
	UNSUPPORTED_MODE,
	FUCKY_BEHAVIOUR,
	INTERNAL_ERROR
}

interface ErrorData {
	code: number;
	message: string;
}

export const RunValidationErrors: Record<RunValidationErrorType, ErrorData> = {
	[RunValidationErrorType.BAD_TIMESTAMPS]: {
		code: 0,
		message: 'run timestamps were misordered'
	},
	[RunValidationErrorType.BAD_REPLAY_FILE]: {
		code: 1,
		message: 'invalid replay file'
	},
	[RunValidationErrorType.BAD_META]: { code: 2, message: 'invalid metadata' },
	[RunValidationErrorType.INVALID_STATS]: { code: 3, message: 'invalid stats' },
	[RunValidationErrorType.OUT_OF_SYNC]: {
		code: 4,
		message: 'replay data out of sync with submission times'
	},
	[RunValidationErrorType.UNSUPPORTED_MODE]: {
		code: 5,
		message: 'this mode is not currently supported'
	},
	[RunValidationErrorType.FUCKY_BEHAVIOUR]: {
		code: 6,
		message: 'unusual behaviour in replay'
	},
	[RunValidationErrorType.INTERNAL_ERROR]: {
		code: 7,
		message: 'an internal server error occurred'
	}
} as const;

export class RunValidationError extends Error {
	code: number;

	constructor(type: RunValidationErrorType) {
		super(RunValidationErrors[type].message);
		this.code = RunValidationErrors[type].code;
	}
}

export enum Style {
	NONE = 0,
	HSW = 1 << 0,
	SW = 1 << 1,
	BW = 1 << 2
}

export enum TrackType {
	MAIN = 0,
	STAGE = 1,
	BONUS = 2
}

export const TrackTypeName: ReadonlyMap<TrackType, string> = new Map([
	[TrackType.MAIN, 'Main'],
	[TrackType.STAGE, 'Stage'],
	[TrackType.BONUS, 'Bonus']
]);

export const BanNames: ReadonlyMap<Ban, string> = new Map([
	[Ban.LEADERBOARDS, 'Leaderboards'],
	[Ban.ALIAS, 'Alias'],
	[Ban.AVATAR, 'Avatar'],
	[Ban.BIO, 'Bio'],
	[Ban.MAP_SUBMISSION, 'Map submission']
]);

export const GamemodeCategories: ReadonlyMap<GamemodeCategory, Array<Gamemode>> = new Map([
	[GamemodeCategory.SURF, [Gamemode.SURF]],
	[GamemodeCategory.BHOP, [Gamemode.BHOP, Gamemode.BHOP_HL1]],
	[GamemodeCategory.RJ, [Gamemode.RJ]],
	[GamemodeCategory.SJ, [Gamemode.SJ]],
	[GamemodeCategory.AHOP, [Gamemode.AHOP]],
	[GamemodeCategory.CONC, [Gamemode.CONC]],
	[GamemodeCategory.DEFRAG, [Gamemode.DEFRAG_CPM, Gamemode.DEFRAG_VQ3, Gamemode.DEFRAG_VTG]],
	[GamemodeCategory.CLIMB, [Gamemode.CLIMB_KZT, Gamemode.CLIMB_MOM, Gamemode.CLIMB_16]]
]);

// See mom_system_gamemode.h for CPP version of similar properties
export interface GamemodeInfoProperties {
	category: GamemodeCategory;
	name: string;
	id: string;
	prefix: string;
	icon: string;
}

export const GamemodeInfo: ReadonlyMap<Gamemode, GamemodeInfoProperties> = new Map([
	[
		Gamemode.SURF,
		{
			category: GamemodeCategory.SURF,
			name: 'Surf',
			id: 'surf',
			prefix: 'surf',
			icon: 'surf'
		}
	],
	[
		Gamemode.BHOP,
		{
			category: GamemodeCategory.BHOP,
			name: 'Bhop',
			id: 'bhop',
			prefix: 'bhop',
			icon: 'bhop'
		}
	],
	[
		Gamemode.BHOP_HL1,
		{
			category: GamemodeCategory.BHOP,
			name: 'Bhop (HL1)',
			id: 'bhop_hl',
			prefix: 'bhophl',
			icon: 'bhop'
		}
	],
	[
		Gamemode.CLIMB_MOM,
		{
			category: GamemodeCategory.CLIMB,
			name: 'Climb (Momentum)',
			id: 'kz_mom',
			prefix: 'kz',
			icon: 'climb'
		}
	],
	[
		Gamemode.CLIMB_KZT,
		{
			category: GamemodeCategory.CLIMB,
			name: 'Climb (KZT)',
			id: 'kz_kzt',
			prefix: 'kzt',
			icon: 'climb'
		}
	],
	[
		Gamemode.CLIMB_16,
		{
			category: GamemodeCategory.CLIMB,
			name: 'Climb (1.6)',
			id: 'kz_16',
			prefix: 'kz16',
			icon: 'climb'
		}
	],
	[
		Gamemode.RJ,
		{
			category: GamemodeCategory.RJ,
			name: 'Rocket Jump',
			id: 'rj',
			prefix: 'rj',
			icon: 'rj'
		}
	],
	[
		Gamemode.SJ,
		{
			category: GamemodeCategory.SJ,
			name: 'Sticky Jump',
			id: 'sj',
			prefix: 'sj',
			icon: 'sj'
		}
	],
	[
		Gamemode.AHOP,
		{
			category: GamemodeCategory.AHOP,
			name: 'Ahop',
			id: 'ahop',
			prefix: 'ahop',
			icon: 'ahop'
		}
	],
	[
		Gamemode.CONC,
		{
			category: GamemodeCategory.CONC,
			name: 'Conc',
			id: 'conc',
			prefix: 'conc',
			icon: 'conc'
		}
	],
	[
		Gamemode.DEFRAG_CPM,
		{
			category: GamemodeCategory.DEFRAG,
			name: 'Defrag (CPM)',
			id: 'df_cpm',
			prefix: 'df',
			icon: 'defrag'
		}
	],
	[
		Gamemode.DEFRAG_VQ3,
		{
			category: GamemodeCategory.DEFRAG,
			name: 'Defrag (VQ3)',
			id: 'df_vq3',
			prefix: 'df',
			icon: 'defrag'
		}
	],
	[
		Gamemode.DEFRAG_VTG,
		{
			category: GamemodeCategory.DEFRAG,
			name: 'Defrag (Vintage)',
			id: 'df_vtg',
			prefix: 'df',
			icon: 'defrag'
		}
	]
]);

// Silly little system for passing whole categories into this structure, rather
// than each individual gamemode, but structured so we could do single gamemodes
// in future if needed. Lots of these are singleton categories but using them
// for future-proofing, for example 100t surf would have the exact same rules
// as regular surf.
// JAVASCRIPT PLEASE ADD CONSTEXPR!!!
const G = Gamemode; //
const GC = GamemodeCategory;
const Cats = (...gcs: GamemodeCategory[]) => gcs.flatMap((gc) => GamemodeCategories.get(gc)!);

/**
 * A non-reflexive map of gamemodes and collections of gamemodes they can
 * *never* have compatibile leaderboards for.
 *
 * For example, there's *never* a possible case
 * where a surf leaderboard should also have a bhop leaderboard, that'd just be
 * jank 100-tick surf.
 *
 * Note the non-reflexivity, you might have a surf map that's worth a
 * leaderboard in ahop (e.g. utopia), but a ahop map would never have a surf
 * leaderboard, since that'd just be bhop with worse settings.
 */
export const IncompatibleGamemodes: ReadonlyMap<Gamemode, ReadonlySet<Gamemode>> = new Map(
	[
		[G.SURF, [Cats(GC.BHOP, GC.CLIMB)]],
		[G.BHOP, [Cats(GC.SURF, GC.CLIMB)]],
		[G.BHOP_HL1, [Cats(GC.SURF, GC.CLIMB)]],
		[G.CLIMB_MOM, [Cats(GC.SURF, GC.BHOP)]],
		[G.CLIMB_KZT, [Cats(GC.SURF, GC.BHOP)]],
		[G.CLIMB_16, [Cats(GC.SURF, GC.BHOP)]],
		[G.RJ, [Cats(GC.SURF, GC.CLIMB, GC.BHOP, GC.AHOP)]],
		[G.SJ, [Cats(GC.SURF, GC.CLIMB, GC.BHOP, GC.AHOP)]],
		[G.AHOP, [Cats(GC.SURF, GC.CLIMB)]],
		[G.CONC, [Cats(GC.SURF, GC.CLIMB, GC.BHOP, GC.AHOP)]],
		[G.DEFRAG_CPM, [Cats(GC.SURF, GC.CLIMB)]],
		[G.DEFRAG_VQ3, [Cats(GC.SURF, GC.CLIMB)]],
		[G.DEFRAG_VTG, [Cats(GC.SURF, GC.CLIMB)]]
	].map(([k, v]) => [k as Gamemode, new Set((v as [Gamemode | Gamemode[]]).flat())])
);

export const LeaderboardTypeName: ReadonlyMap<LeaderboardType, string> = new Map([
	[LeaderboardType.RANKED, 'Ranked'],
	[LeaderboardType.UNRANKED, 'Unranked'],
	[LeaderboardType.HIDDEN, 'Hidden']
]);

export const MapCreditNames: ReadonlyMap<MapCreditType, string> = new Map([
	[MapCreditType.AUTHOR, 'Authors'],
	[MapCreditType.CONTRIBUTOR, 'Contributors'],
	[MapCreditType.TESTER, 'Testers'],
	[MapCreditType.SPECIAL_THANKS, 'Special Thanks']
]);

/**
 * Stores what changes between map statuses are allowed by what users
 *
 * In table form:
 *
 * | From(Down), To(Across) | Approved | Private Testing | Content Approval | Public Testing | Final Approval | Disabled |
 * | ---------------------- | -------- | --------------- | ---------------- | -------------- | -------------- | -------- |
 * | Approved               |          |                 |                  |                |                | AM       |
 * | Private Testing        |          |                 | S                |                |                | AM       |
 * | Content Approval       |          | S               |                  | RAM            | AM             | AM       |
 * | Public Testing         |          |                 | AM               |                | S              | AM       |
 * | Final Approval         | AM       |                 |                  | S              |                | AM       |
 * | Disabled               | A†       | A               | A                | A              | A              |          |
 *
 * † Admins can only move from disabled to approved if the map has been approved once in the past
 */
export const MapStatusChangeRules: ReadonlyArray<{ from: MapStatus; to: MapStatus; roles: Array<Role | 'submitter'> }> =
	[
		{ from: MapStatus.APPROVED, to: MapStatus.APPROVED, roles: [] },
		{ from: MapStatus.APPROVED, to: MapStatus.PRIVATE_TESTING, roles: [] },
		{ from: MapStatus.APPROVED, to: MapStatus.CONTENT_APPROVAL, roles: [] },
		{ from: MapStatus.APPROVED, to: MapStatus.PUBLIC_TESTING, roles: [] },
		{ from: MapStatus.APPROVED, to: MapStatus.FINAL_APPROVAL, roles: [] },
		{ from: MapStatus.APPROVED, to: MapStatus.DISABLED, roles: [Role.ADMIN, Role.MODERATOR] },

		{ from: MapStatus.PRIVATE_TESTING, to: MapStatus.APPROVED, roles: [] },
		{ from: MapStatus.PRIVATE_TESTING, to: MapStatus.PRIVATE_TESTING, roles: [] },
		{ from: MapStatus.PRIVATE_TESTING, to: MapStatus.CONTENT_APPROVAL, roles: ['submitter'] },
		{ from: MapStatus.PRIVATE_TESTING, to: MapStatus.PUBLIC_TESTING, roles: [] },
		{ from: MapStatus.PRIVATE_TESTING, to: MapStatus.FINAL_APPROVAL, roles: [] },
		{ from: MapStatus.PRIVATE_TESTING, to: MapStatus.DISABLED, roles: [Role.ADMIN, Role.MODERATOR] },

		{ from: MapStatus.CONTENT_APPROVAL, to: MapStatus.APPROVED, roles: [] },
		{ from: MapStatus.CONTENT_APPROVAL, to: MapStatus.PRIVATE_TESTING, roles: ['submitter'] },
		{ from: MapStatus.CONTENT_APPROVAL, to: MapStatus.CONTENT_APPROVAL, roles: [] },
		{
			from: MapStatus.CONTENT_APPROVAL,
			to: MapStatus.PUBLIC_TESTING,
			roles: [Role.REVIEWER, Role.ADMIN, Role.MODERATOR]
		},
		{ from: MapStatus.CONTENT_APPROVAL, to: MapStatus.FINAL_APPROVAL, roles: [Role.ADMIN, Role.MODERATOR] },
		{ from: MapStatus.CONTENT_APPROVAL, to: MapStatus.DISABLED, roles: [Role.ADMIN, Role.MODERATOR] },

		{ from: MapStatus.PUBLIC_TESTING, to: MapStatus.APPROVED, roles: [] },
		{ from: MapStatus.PUBLIC_TESTING, to: MapStatus.PRIVATE_TESTING, roles: [] },
		{ from: MapStatus.PUBLIC_TESTING, to: MapStatus.CONTENT_APPROVAL, roles: [Role.ADMIN, Role.MODERATOR] },
		{ from: MapStatus.PUBLIC_TESTING, to: MapStatus.PUBLIC_TESTING, roles: [] },
		{ from: MapStatus.PUBLIC_TESTING, to: MapStatus.FINAL_APPROVAL, roles: ['submitter'] },
		{ from: MapStatus.PUBLIC_TESTING, to: MapStatus.DISABLED, roles: [Role.ADMIN, Role.MODERATOR] },

		{ from: MapStatus.FINAL_APPROVAL, to: MapStatus.APPROVED, roles: [Role.ADMIN, Role.MODERATOR] },
		{ from: MapStatus.FINAL_APPROVAL, to: MapStatus.PRIVATE_TESTING, roles: [] },
		{ from: MapStatus.FINAL_APPROVAL, to: MapStatus.CONTENT_APPROVAL, roles: [] },
		{ from: MapStatus.FINAL_APPROVAL, to: MapStatus.PUBLIC_TESTING, roles: ['submitter'] },
		{ from: MapStatus.FINAL_APPROVAL, to: MapStatus.FINAL_APPROVAL, roles: [] },
		{ from: MapStatus.FINAL_APPROVAL, to: MapStatus.DISABLED, roles: [Role.ADMIN, Role.MODERATOR] },

		{ from: MapStatus.DISABLED, to: MapStatus.APPROVED, roles: [Role.ADMIN] },
		{ from: MapStatus.DISABLED, to: MapStatus.PRIVATE_TESTING, roles: [Role.ADMIN] },
		{ from: MapStatus.DISABLED, to: MapStatus.CONTENT_APPROVAL, roles: [Role.ADMIN] },
		{ from: MapStatus.DISABLED, to: MapStatus.PUBLIC_TESTING, roles: [Role.ADMIN] },
		{ from: MapStatus.DISABLED, to: MapStatus.FINAL_APPROVAL, roles: [Role.ADMIN] },
		{ from: MapStatus.DISABLED, to: MapStatus.DISABLED, roles: [] }
	];

export const MapStatusName: ReadonlyMap<MapStatus, string> = new Map([
	[MapStatus.APPROVED, 'Approved'],
	[MapStatus.PRIVATE_TESTING, 'Private Testing'],
	[MapStatus.CONTENT_APPROVAL, 'Content Approval'],
	[MapStatus.PUBLIC_TESTING, 'Public Testing'],
	[MapStatus.FINAL_APPROVAL, 'Final Approval'],
	[MapStatus.DISABLED, 'Disabled']
]);

export const RoleNames: ReadonlyMap<Role, string> = new Map([
	[Role.ADMIN, 'Admin'],
	[Role.MODERATOR, 'Moderator'],
	[Role.MAPPER, 'Mapper'],
	[Role.PORTER, 'Porter'],
	[Role.DELETED, 'Deleted'],
	[Role.PLACEHOLDER, 'Placeholder'],
	[Role.REVIEWER, 'Reviewer'],
	[Role.VERIFIED, 'Verified']
]);

/**
 * The tickrates each gamemode uses. May change in future when we allow surf
 * 100 tick etc. 0.015 <=> 66
 * 0.01 <=> 100
 * 0.008 <=> 125
 * 0.0078125 <=> 128
 */
export const Tickrates: ReadonlyMap<Gamemode, number> = new Map([
	[Gamemode.AHOP, 0.015],
	[Gamemode.BHOP, 0.01],
	[Gamemode.BHOP_HL1, 0.004],
	[Gamemode.CLIMB_MOM, 0.01],
	[Gamemode.CLIMB_KZT, 0.01],
	[Gamemode.CLIMB_16, 0.01],
	[Gamemode.CONC, 0.01],
	[Gamemode.DEFRAG_CPM, 0.008],
	[Gamemode.DEFRAG_VQ3, 0.008],
	[Gamemode.DEFRAG_VTG, 0.008],
	[Gamemode.RJ, 0.015],
	[Gamemode.SJ, 0.015],
	[Gamemode.SURF, 0.015]
]);

export const ISO_8601_REGEXP =
	/[+-]?\d{4}(-[01]\d(-[0-3]\d(T[0-2]\d:[0-5]\d:?([0-5]\d(\.\d+)?)?[+-][0-2]\d:[0-5]\dZ?)?)?)?/;

export const MAP_NAME_REGEXP = /^[a-z][\d_a-z-]+$/;

// Checks user alias for whitespace including braille whitespace which
// javascript's regex engine doesn't include in \s.
export const NON_WHITESPACE_REGEXP = /^(?![\s\u2800]*$).+/;

export const YOUTUBE_ID_REGEXP = /^[\w-_]{11}$/;

// Collection of models used throughout the codebase, as well as in Panorama.
//
// We don't use Prisma types anymore, since
// - Data exported from the backend often has small difference from how it's
//   stored in DB.
// - Prisma schemas *still* can't specific types for Json values.
// - Prisma types are absurdly complicated, and slow down the TypeScript
//   language server.
// - Fuck Prisma.

//#region User

export interface User {
	id: number;
	steamID: string;
	alias: string;
	avatarURL: string;
	country: string | null;
	roles: Flags<Role>;
	bans: Flags<Ban>;
	createdAt: DateString;
	profile?: Profile;
	userStats?: UserStats;
}

export interface Profile {
	bio: string;
	socials: Socials;
}

export type Socials = {
	Discord?: string;
	Twitch?: string;
	YouTube?: string;
	Github?: string;
	Twitter?: string;
	Mastodon?: string;
	LinkedIn?: string;
	Instagram?: string;
	Spotify?: string;
	Patreon?: string;
	'Ko-fi'?: string;
	Paypal?: string;
};

export interface UserStats {
	cosXP: number;
	level: number;
	mapsCompleted: number;
	runsSubmitted: number;
	totalJumps: number;
	totalStrafes: number;
}

export interface Activity {
	id: number;
	userID: number;
	data: number;
	type: ActivityType;
	user?: User;
	createdAt: DateString;
	updatedAt: DateString;
}

export interface Notification {
	id: number;
	read: boolean;
	userID: number;
	user?: User;
	activityID: number;
	activity?: Activity;
	createdAt: DateString;
	updatedAt: DateString;
}

export interface Follow {
	followedID: number;
	followeeID: number;
	notifyOn: Flags<ActivityType>;
	followed?: User;
	followee?: User;
	createdAt: DateString;
}

export interface FollowStatus {
	local?: Follow;
	target?: Follow;
}

export interface MapSummary {
	status: MapStatus;
	statusCount: number;
}

//#endregion
//#region Auth

export interface JWTResponseWeb {
	accessToken: string;
	refreshToken: string;
	expiresIn: string;
}

export interface JWTResponseGame {
	token: string;
	length: number;
}

export interface RefreshToken {
	refreshToken: string;
}

//#endregion User
//#region Admin

export interface AdminActivity {
	id: number;
	comment: string | null;
	type: AdminActivityType;
	target: number;
	oldData: object;
	newData: object;
	userID: number;
	user?: User;
	createdAt: DateString;
}

export type Killswitches = Record<KillswitchType, boolean>;

//#endregion
//#region Reports

export interface Report {
	id: number;
	data: number;
	type: ReportType;
	category: ReportCategory;
	message: string;
	resolved: boolean;
	resolutionMessage?: string;
	submitterID: number;
	submitter: User;
	resolverID: number | null;
	resolver?: User;
	createdAt: DateString;
	updatedAt: DateString;
}

//#endregion
//#region Maps

export interface MMap {
	id: number;
	name: string;
	status: MapStatus;
	downloadURL: string;
	hash: string;
	vmfDownloadURL: string;
	submitterID: number;
	createdAt: DateString;
	updatedAt: DateString;
	zones: MapZones;
	info: MapInfo;
	submission: MapSubmission;
	submitter: User;
	images: MapImage[];
	thumbnail: MapImage;
	stats: MapStats;
	credits: MapCredit[];
	favorites: MapFavorite[];
	leaderboards: Leaderboard[];
	worldRecords: LeaderboardRun[];
	personalBests: LeaderboardRun[];
	testInvites?: MapTestInvite[];
}

export interface MapInfo {
	description: string;
	youtubeID: string;
	creationDate: DateString;
}

export interface MapCredit {
	type: MapCreditType;
	description: string | null;
	userID: number;
	user?: User;
	mapID: number;
	map?: MMap;
}

export interface MapFavorite {
	id: number;
	userID: number;
	user?: User;
	mapID: number;
	map?: MMap;
	createdAt: DateString;
}

export interface MapImage {
	id: string;
	small: string;
	medium: string;
	large: string;
	xl: string;
}

export interface MapListVersion {
	approved: number;
	approvedURL: string;
	submissions: number;
	submissionsURL: string;
}

export interface MapNotify {
	notifyOn: ActivityType;
	mapID: number;
	userID: number;
	createdAt: DateString;
	updatedAt: DateString;
}

export interface MapPreSignedUrl {
	url: string;
}

export interface MapReview {
	id: number;
	mainText: string;
	comments: MapReviewComment[];
	numComments: number;
	suggestions: MapReviewSuggestion[];
	editHistory: MapReviewEdit[];
	map: MMap;
	mapID: number;
	reviewerID: number;
	reviewer?: User;
	images: string[];
	resolved: boolean | null;
	resolverID: number;
	resolver?: User;
	createdAt: DateString;
	updatedAt: DateString;
}

export interface MapReviewComment {
	id: number;
	reviewID: number;
	text: string;
	reviewerID?: number;
	reviewer?: User;
	userID: number;
	user?: User;
	createdAt: DateString;
	updatedAt: DateString;
}

export interface MapReviewEdit {
	mainText?: string;
	resolved?: boolean | null;
	editorID: number;
	date: DateString;
}

export interface MapReviewSuggestion {
	gamemode: Gamemode;
	trackType: TrackType;
	trackNum: number;
	tier?: number;
	gameplayRating?: number;
}

export interface MapStats {
	reviews: number;
	downloads: number;
	subscriptions: number;
	plays: number;
	favorites: number;
	completions: number;
	uniqueCompletions: number;
	timePlayed: number;
	baseStats: BaseStats;
}

export interface MapSubmission {
	type: MapSubmissionType;
	suggestions: MapSubmissionSuggestion[];
	placeholders: MapSubmissionPlaceholder[];
	dates: MapSubmissionDate[];
	currentVersion: MapSubmissionVersion;
	versions: MapSubmissionVersion[];
}

export interface MapSubmissionApproval {
	trackType: TrackType;
	trackNum: number;
	gamemode: Gamemode;
	tier?: number; // Hidden leaderboards don't have tiers
	type: Exclude<LeaderboardType, LeaderboardType.IN_SUBMISSION>;
}

export type MapSubmissionDate = {
	status: MapStatus;
	date: DateString;
};

export interface MapSubmissionPlaceholder {
	alias: string;
	type: MapCreditType;
	description?: string;
}

export interface MapSubmissionSuggestion {
	trackType: TrackType;
	trackNum: number;
	gamemode: Gamemode;
	tier: number;
	type: LeaderboardType.RANKED | LeaderboardType.UNRANKED;
	comment?: string;
}

export interface MapSubmissionVersion {
	id: string;
	versionNum: number;
	changelog: string;
	zones: MapZones;
	hash: string;
	downloadURL: string;
	vmfDownloadURL?: string;
	createdAt: DateString;
}

export type MapTags = string[];

export interface MapTestInvite {
	mapID: number;
	userID: number;
	user?: User;
	state: MapTestInviteState;
	createdAt: DateString;
	updatedAt: DateString;
}

//#endregion
//#region Map Zones

export interface MapZones {
	formatVersion: number;
	dataTimestamp: number;
	maxVelocity?: number;
	tracks: MapTracks;
}

export interface MapTracks {
	main: MainTrack;
	bonuses: BonusTrack[];
}

export interface MainTrack {
	zones: TrackZones;
	stagesEndAtStageStarts: boolean;
}

export interface BonusTrack {
	zones?: TrackZones;
	defragModifiers?: number;
}

export interface TrackZones {
	segments: Segment[];
	end: Zone;
}

export interface Segment {
	checkpoints: Zone[];
	cancel: Zone[];
	name?: string;
	limitStartGroundSpeed: boolean;
	checkpointsRequired: boolean;
	checkpointsOrdered: boolean;
}

export interface Zone {
	regions: Region[];
	filtername?: string;
}

export interface Region {
	points: Vector2D[];
	bottom: number;
	height: number;
	teleDestTargetname?: string;
	teleDestPos?: Vector;
	teleDestYaw?: number;
	safeHeight?: number;
}

//#endregion
//#region Zone Validation

export const CURRENT_ZONE_FORMAT_VERSION = 1;

export const MAX_COORD_FLOAT = 65536;
export const MIN_COORD_FLOAT = -MAX_COORD_FLOAT;

export const MAX_ZONE_REGION_POINTS = 64;

export const MAX_TRACK_SEGMENTS = 255;
export const MAX_STAGE_TRACKS = MAX_TRACK_SEGMENTS;
export const MAX_BONUS_TRACKS = 255;

// Includes the segment start zone
export const MAX_SEGMENT_CHECKPOINTS = 255;

// From C++:
// One segment start for max Main segments plus Main end zone plus start and end for each stage track.
// The limit could be increased from here (barring region entity overload) but this is the bare minimum to allow for MAX_TRACK_SEGMENTS.
export const MAX_ZONES_ALL_TRACKS = MAX_TRACK_SEGMENTS + 1 + MAX_STAGE_TRACKS * 2;

export class ZoneValidationError extends Error {
	constructor(message: string) {
		super(message);
		this.name = 'ZoneValidationError';
	}
}

type Track = MainTrack | BonusTrack | { zones: TrackZones };

/**
 * Validate a MapZones JavaScript Object
 * @throws ZoneValidationError
 */
export function validateZoneFile(input: MapZones): void {
	if (!input) throw new ZoneValidationError('Bad input data');

	const { tracks, formatVersion } = input;

	if (!tracks) throw new ZoneValidationError('Missing tracks');

	if (formatVersion !== CURRENT_ZONE_FORMAT_VERSION) throw new ZoneValidationError('Bad format version');

	let totalZones = 0;

	const mainSegmentCount = tracks.main.zones.segments.length;
	const stageTrackCount = mainSegmentCount > 1 ? mainSegmentCount : 0;

	// Main track
	if (mainSegmentCount === 0) {
		throw new ZoneValidationError('The Main track has no segments');
	}

	validateTrack(tracks.main, 'Main');

	// Stages
	for (let stageIndex = 0; stageIndex < stageTrackCount; stageIndex++) {
		const currSegment = tracks.main.zones.segments[stageIndex];

		const name = `Stage ${stageIndex + 1}`;
		if (stageIndex + 1 < mainSegmentCount) {
			if (tracks.main.stagesEndAtStageStarts) {
				validateTrack(
					{
						zones: {
							segments: [currSegment],
							end: tracks.main.zones.segments[stageIndex + 1].checkpoints[0]
						}
					},
					name
				);
			} else {
				if (currSegment.checkpoints.length < 2)
					// If stagesEndAtStageStarts is true, 1 checkpoint segments are fine,
					// otherwise they make no sense.
					throw new ZoneValidationError(
						`${name} does not have a checkpoint to use as a ` +
							'stage track end. Add a checkpoint or use stagesEndAtStageStarts.'
					);

				if (!currSegment.checkpointsOrdered)
					throw new ZoneValidationError(
						`Stage ${stageIndex + 1} wants to use its last checkpoint as the ` +
							'stage track end but has checkpointsOrdered == false. ' +
							'Enable at least one of checkpointsOrdered or stagesEndAtStageStarts.'
					);

				validateTrack(
					{
						zones: {
							segments: [
								{
									...currSegment,
									checkpoints: currSegment.checkpoints.slice(0, -1)
								}
							],
							end: currSegment.checkpoints.at(-1)!
						}
					},
					name
				);
			}
		} else {
			validateTrack({ zones: { segments: [currSegment], end: tracks.main.zones.end } }, name);
		}
	}

	if (tracks.bonuses?.length ?? 0 > MAX_BONUS_TRACKS) throw new ZoneValidationError('Too many bonus tracks');

	for (const [bonusIndex, bonusTrack] of tracks.bonuses?.entries() ?? []) {
		if (Boolean(bonusTrack.zones) === Boolean(bonusTrack.defragModifiers))
			throw new ZoneValidationError(
				`Bonus ${bonusIndex + 1} track must specify exactly one of zones or defragModifiers`
			);

		if (bonusTrack.zones) {
			if (bonusTrack.zones.segments.length !== 1)
				throw new ZoneValidationError(`Bonus ${bonusIndex + 1} track must have a single segment`);
		} else {
			if (mainSegmentCount > 1)
				throw new ZoneValidationError(
					`Bonus ${bonusIndex + 1} track is a Defrag modifier bonus but modifiers can only be used when the Main track has one segment`
				);
		}

		validateTrack(bonusTrack, `bonus ${bonusIndex}`);
	}

	if (totalZones > MAX_ZONES_ALL_TRACKS) throw new ZoneValidationError('Too many zones in total');

	function validateTrack(track: Track, debugName: string) {
		const { zones } = track;

		if (!zones) return; // Defrag modifiers (already checked they exist)

		if (zones.segments.length > MAX_TRACK_SEGMENTS)
			throw new ZoneValidationError(`Track ${debugName} has too many segments`);

		for (const [segmentIndex, segment] of zones.segments.entries()) {
			const thr = (str: string) => {
				throw new ZoneValidationError(`Track ${debugName} segment ${segmentIndex + 1} ${str}`);
			};

			if (!Array.isArray(segment?.checkpoints)) {
				thr('has no checkpoints');
			}

			if (segment.checkpoints.length + 1 > MAX_SEGMENT_CHECKPOINTS) {
				thr('has too many checkpoints');
			}

			if (!segment.checkpoints?.[0]) {
				thr('has no start zone');
			}

			(['limitStartGroundSpeed', 'checkpointsRequired', 'checkpointsOrdered'] as const)
				.filter((k) => !(segment[k] === true || segment[k] === false))
				.forEach((k) => thr(`${k} must be a boolean`));

			validateZone(segment.checkpoints[0], debugName, `segment ${segmentIndex + 1} start zone`, true);

			segment.checkpoints
				.slice(1)
				.forEach((checkpoint) =>
					validateZone(checkpoint, debugName, `segment ${segmentIndex + 1} checkpoint zone`, false)
				);

			segment.cancel?.forEach((cancel) =>
				validateZone(cancel, debugName, `segment ${segmentIndex + 1} cancel zone`, false)
			);
		}

		validateZone(zones.end, debugName, 'end zone', false);
	}

	function validateZone(zone: Zone, trackName: string, zoneName: string, requiresTele: boolean) {
		if (!zone) throw new ZoneValidationError('Missing zones');

		totalZones++;

		if (!Array.isArray(zone.regions) || zone.regions.length === 0)
			throw new ZoneValidationError(`Track ${trackName} ${zoneName} has no regions`);

		for (const [regionIndex, region] of zone.regions.entries()) {
			const thr = (str: string) => {
				throw new ZoneValidationError(`Track ${trackName} ${zoneName} region ${regionIndex} ${str}`);
			};

			if (!Array.isArray(region.points)) {
				thr('has no points');
			}

			if (region.points.length < 3) {
				thr('does not have enough points');
			}

			if (region.points.length > MAX_ZONE_REGION_POINTS) {
				thr('has too many points');
			}

			if (region.bottom == null) {
				thr('has no bottom position');
			}

			if (!(region.bottom >= MIN_COORD_FLOAT && region.bottom < MAX_COORD_FLOAT)) {
				thr('bottom is out of bounds');
			}

			if (region.height == null || region.height <= 0) {
				thr('has no height');
			}

			if (region.bottom + region.height > MAX_COORD_FLOAT) {
				thr('is too high');
			}

			const MIN_DIST = 4;
			const MIN_ANGLE = Math.PI * (15 / 180);

			const points = region.points.map((vec) => arrayToVector(vec));
			const count = points.length;

			for (let i = 0; i < count; i++) {
				const prev1 = points[(i - 1 + count) % count];
				const curr1 = points[i];
				const next1 = points[(i + 1) % count];

				if (
					!(
						curr1.x >= MIN_COORD_FLOAT &&
						curr1.x <= MAX_COORD_FLOAT &&
						curr1.y >= MIN_COORD_FLOAT &&
						curr1.y <= MAX_COORD_FLOAT
					)
				) {
					thr(`point ${i} is out of bounds`);
				}

				const line1 = subtractVector2D(prev1, curr1);
				const line2 = subtractVector2D(next1, curr1);

				const d1 = magnitude2D(line1);
				const d2 = magnitude2D(line2);

				if (d1 < MIN_DIST || d2 < MIN_DIST || d1 <= 0 || d2 <= 0)
					thr('polygon vertices are too close to each other');

				const angle = Math.acos(dot2D(line1, line2) / (d1 * d2));

				if (angle < MIN_ANGLE) thr('polygon has an angle which is too small');

				if (angle > Math.PI - 0.0001) thr('polygon has colinear points');

				if (
					count <= 3 || // Triangles can't self-intersect
					i === count - 1 // Skip a case we don't want to check
				)
					continue;

				// Loop through every line segment not connected to i, i + 1 segment
				for (let j = i + 2; j < count; j++) {
					// Skip another bad case
					if (i === 0 && j === count - 1) continue;

					// line2 is vec between curr and next of first loop
					const curr2 = points[j];
					const next2 = points[(j + 1) % count];

					// https://bryceboe.com/2006/10/23/line-segment-intersection-algorithm/
					if (
						isCCW(curr1, curr2, next2) !== isCCW(next1, curr2, next2) &&
						isCCW(curr1, next1, curr2) !== isCCW(curr1, next1, next2)
					)
						thr('polygon is self-intersecting');
				}
			}

			const isNum = (p: any) => typeof p === 'number' && !Number.isNaN(+p);
			if (region.teleDestPos !== undefined) {
				if (region.teleDestTargetname !== undefined)
					thr('must not specify both a targetname-based and a custom position-based destination');

				if (region.teleDestYaw === undefined) thr('must specify teleDestYaw if teleDestPos is specified');

				if (region.teleDestPos.length !== 3 || !region.teleDestPos.every(isNum))
					thr('teleDestPos must be a 3-tuple of numbers');

				if (!isNum(region.teleDestYaw)) {
					thr('teleDestYaw must be a number');
				}
			} else {
				if (requiresTele && region.teleDestTargetname === undefined)
					thr('must specify either a targetname-based or a custom position-based destination');
			}
		}
	}
}

//#endregion
//#region Stats

export interface BaseStats {
	jumps: number;
	strafes: number;
	avgStrafeSync: number;
	avgStrafeSync2: number;
	enterTime: number;
	totalTime: number;
	velAvg3D: number;
	velAvg2D: number;
	velMax3D: number;
	velMax2D: number;
	velEnter3D: number;
	velEnter2D: number;
	velExit3D: number;
	velExit2D: number;
}

export interface RunStats {
	overall: BaseStats;
	zones?: any;
}

export interface Leaderboard {
	gamemode: Gamemode;
	trackType: TrackType;
	trackNum: number;
	tier: number | null;
	style: Style;
	type: LeaderboardType;
	tags: MapTags;
	linear: boolean;
}

export interface LeaderboardStats {
	leaderboard: Leaderboard;
	totalRuns: number;
}

export interface LeaderboardRun {
	gamemode: Gamemode;
	trackType: TrackType;
	trackNum: number;
	style: Style;
	time: number;
	downloadURL: string;
	replayHash: string;
	flags: Style[];
	stats: RunStats;
	rank: number;
	rankXP: number;
	userID: number;
	user?: User;
	mapID: number;
	map?: MMap;
	pastRunID: number;
	pastRun?: PastRun;
	leaderboard?: Leaderboard;
	createdAt: DateString;
}

export interface PastRun {
	id: number;
	gamemode: Gamemode;
	trackType: TrackType;
	trackNum: number;
	style: Style;
	time: number;
	flags: Style[];
	isPB: boolean;
	userID: number;
	user?: User;
	mapID: number;
	map?: MMap;
	leaderboardRun?: LeaderboardRun;
	createdAt: DateString;
}

export interface RunSession {
	id: number;
	mapID: number;
	gamemode: Gamemode;
	trackType: TrackType;
	trackNum: number;
	userID: number;
	createdAt: DateString;
}

export interface RunSessionTimestamp {
	id: number;
	segment: number;
	checkpoint: number;
	time: number;
	sessionID: number;
	createdAt: DateString;
}

export interface XpGain {
	rankXP: number;
	cosXP: {
		gainLvl: number;
		oldXP: number;
		gainXP: number;
	};
}

export interface CompletedRun {
	isNewWorldRecord: boolean;
	isNewPersonalBest: boolean;
	run: LeaderboardRun;
	xp: XpGain;
}

//#endregion
//#region Misc

 
export interface TwitchStream {
	title: string;
	user_name: string;
	viewer_count: number;
	started_at: string;
	thumbnail_url: string;
}
//#endregion

export interface PagedResponse<T> {
	totalCount: number;
	returnCount: number;
	data: T[];
}

export type ActivitiesGetQuery = PagedQuery & {
	userID?: number;
	type?: ActivityType;
	data?: number;
};

export type UpdateNotification = Pick<Notification, 'read'>;

export type AdminGetReportsExpand = ('submitter' | 'resolver')[];

export type AdminGetReportsQuery = PagedQuery & {
	expand?: AdminGetReportsExpand;
	resolved?: boolean;
};

export type AdminActivitiesGetQuery = PagedQuery & {
	filter?: AdminActivityType;
};

//#region Map

type BaseMapsGetAllExpand = 'zones' | 'leaderboards' | 'info' | 'stats' | 'submitter' | 'credits';

export type MapsGetAllExpand = Array<BaseMapsGetAllExpand | 'inFavorites' | 'personalBest' | 'worldRecord'>;

export type MapsGetAllSubmissionExpand = Array<
	BaseMapsGetAllExpand | 'inFavorites' | 'personalBest' | 'worldRecord' | 'currentVersion' | 'versions' | 'reviews'
>;

type MapsGetAllBaseQuery = {
	skip?: number;
	take?: number;
	search?: string;
	searchStartsWith?: string;
	submitterID?: number;
};

export type MapsGetAllQuery = MapsGetAllBaseQuery & {
	expand?: MapsGetAllExpand;
	gamemode?: Gamemode;
	difficultyLow?: number;
	difficultyHigh?: number;
	linear?: boolean;
	favorite?: boolean;
	PB?: boolean;
};

export type MapsGetAllAdminFilter = Array<MapStatus>;

export type MapsGetAllAdminQuery = MapsGetAllBaseQuery & {
	filter?: MapsGetAllAdminFilter;
};

export type MapsGetAllSubmissionFilter = Array<
	MapStatus.PUBLIC_TESTING | MapStatus.PRIVATE_TESTING | MapStatus.CONTENT_APPROVAL | MapStatus.FINAL_APPROVAL
>;

export type MapsGetAllSubmissionQuery = MapsGetAllBaseQuery & {
	expand?: MapsGetAllSubmissionExpand;
	filter?: MapsGetAllSubmissionFilter;
};

export type MapsGetAllUserSubmissionQuery = Omit<MapsGetAllSubmissionQuery, 'submitterID'>;

export type MapsGetExpand = Array<MapsGetAllSubmissionExpand[number] | 'submission' | 'testInvites'>;

export type MapsGetQuery = { expand?: MapsGetExpand };

export interface CreateMapWithFiles {
	vmfs: File[];
	data: CreateMap;
}

export interface CreateMap extends Pick<MMap, 'name'> {
	submissionType: MapSubmissionType;
	suggestions: MapSubmissionSuggestion[];
	wantsPrivateTesting: boolean;
	placeholders: MapSubmissionPlaceholder[];
	testInvites?: number[];
	info: CreateMapInfo;
	zones: MapZones;
	credits: CreateMapCredit[];
}

export interface UpdateMap
	extends Partial<
		Pick<CreateMap, 'name' | 'suggestions' | 'placeholders' | 'testInvites' | 'credits' | 'submissionType'>
	> {
	status?: MapStatus.CONTENT_APPROVAL | MapStatus.FINAL_APPROVAL;
	info?: UpdateMapInfo;
	zones?: MapZones;
	resetLeaderboards?: boolean;
}

export interface UpdateMapAdmin extends Omit<UpdateMap, 'status'> {
	status?: MapStatus;
	finalLeaderboards?: MapSubmissionApproval[];
}

//#endregion
//#region Map Info

export type CreateMapInfo = Pick<MapInfo, 'description' | 'youtubeID' | 'creationDate'>;

export type UpdateMapInfo = Partial<Pick<CreateMapInfo, 'description' | 'youtubeID' | 'creationDate'>>;

//#endregion
//#region Credits

export type MapCreditsGetExpand = 'user';

export type MapCreditsGetQuery = { expand?: MapCreditsGetExpand };

export type CreateMapCredit = Pick<MapCredit, 'userID' | 'type' | 'description'>;

//#endregion
//#region Images

export interface UpdateMapImages {
	imageIDs: string[];
}

export interface UpdateMapImagesWithFiles {
	images: File[];
	data: UpdateMapImages;
}

//#endregion
//#region Notifications

export type UpdateMapNotify = Pick<MapNotify, 'notifyOn'>;

//#endregion
//#region Runs

export type MapRunsGetExpand = 'stats';
export type MapRunsGetFilter = 'around' | 'friends';

export type MapLeaderboardGetQuery = PagedQuery & {
	gamemode: Gamemode;
	trackType?: TrackType; // Default 0
	trackNum?: number; // Default 1
	style?: Style; // Default 0
	expand?: MapRunsGetExpand;
	filter?: MapRunsGetFilter;
	filterUserIDs?: number[];
	orderByDate?: boolean;
};

export type MapLeaderboardGetRunQuery = PagedQuery & {
	gamemode: Gamemode;
	trackType?: TrackType; // Default 0
	trackNum?: number; // Default 1
	style?: Style; // Default 0
	expand?: MapRunsGetExpand;
	userID?: number;
	rank?: number;
};

//#endregion
//#region Submissions

export interface CreateMapSubmissionVersion extends Pick<MapSubmissionVersion, 'changelog' | 'zones'> {
	resetLeaderboards?: boolean;
}

export interface CreateMapSubmissionVersionWithFiles {
	vmfs: File[];
	data: CreateMapSubmissionVersion;
}

//#endregion
//#region Reviews

export type MapReviewsGetExpand = ('map' | 'reviewer' | 'resolver')[];

export type MapReviewsGetQuery = PagedQuery & {
	official?: boolean;
	expand?: MapReviewsGetExpand;
	comments?: number;
};

export type MapReviewGetIdQuery = {
	expand?: string[];
};

type PickMapReview = Pick<MapReview, 'mainText'> & Partial<Pick<MapReview, 'suggestions'>>;

export interface CreateMapReview extends PickMapReview {
	needsResolving?: boolean;
}

export interface CreateMapReviewWithFiles {
	images?: File[];
	data: CreateMapReview;
}

export interface UpdateMapReview extends Partial<CreateMapReview> {
	resolved?: boolean | null;
}

export type AdminUpdateMapReview = Pick<UpdateMapReview, 'resolved'>;

export type CreateMapReviewComment = Pick<MapReviewComment, 'text'>;
export type UpdateMapReviewComment = CreateMapReviewComment;

//#endregion
//#region Test Invites

export interface CreateMapTestInvite {
	userIDs: number[];
}

export interface UpdateMapTestInvite {
	accept: boolean;
}

//#endregion

export enum Order {
	ASC = 'asc',
	DESC = 'desc'
}

export type PagedQuery = {
	skip?: number;
	take?: number;
};

// Only types work here, not interfaces.
// https://github.com/microsoft/TypeScript/issues/15300#issuecomment-332366024

export type QueryParam = {
	[param: string]: string | number | boolean | ReadonlyArray<string | number | boolean>;
};

export type QueryParamOptional = {
	[param: string]: string | number | boolean | ReadonlyArray<string | number | boolean> | undefined;
};

export type ReportGetExpand = ('submitter' | 'resolver')[];

export type ReportGetQuery = PagedQuery & {
	resolved?: boolean; // Note: this was a string on old API.
	expand?: ReportGetExpand;
};

export type CreateReport = Pick<Report, 'data' | 'type' | 'category' | 'message'>;

export type UpdateReport = Pick<Report, 'resolved' | 'resolutionMessage'>;

export type RunsGetAllExpand = Array<'user' | 'map' | 'leaderboardRun'>;
export enum RunsGetAllOrder {
	DATE = 'createdAt',
	RUN_TIME = 'time'
}

export type RunsGetAllQuery = PagedQuery & {
	expand?: RunsGetAllExpand;
	mapID?: number;
	mapName?: string;
	gamemode?: Gamemode;
	trackType?: TrackType; // Default 0
	trackNum?: number; // Default 1
	style?: Style; // Default 0
	flags?: number[];
	userID?: number;
	userIDs?: number[];
	isPB?: boolean;
	orderBy?: RunsGetAllOrder;
	order?: Order;
};

export type RunsGetExpand = RunsGetAllExpand;

export type RunsGetQuery = {
	expand?: RunsGetExpand;
};

export interface CreateRunSession extends Pick<RunSession, 'mapID' | 'gamemode' | 'trackType' | 'trackNum'> {
	segment: number;
}

export interface UpdateRunSession extends Pick<CreateRunSession, 'segment'> {
	checkpoint: number;
	time: number;
}

export type CreateUser = Pick<User, 'alias'>;

export interface UpdateUser {
	alias?: string;
	bio?: string;
	socials?: Socials;
}

export interface AdminUpdateUser extends UpdateUser {
	roles?: Flags<Role>;
	bans?: Flags<Ban>;
}

export interface MergeUser {
	placeholderID: number;
	userID: number;
}

export type UsersGetExpand = Array<'profile' | 'userStats'>;

export type UsersGetQuery = {
	expand?: UsersGetExpand;
	mapRank?: number;
};

export type UsersGetAllExpand = UsersGetExpand;

export type UsersGetAllQuery = PagedQuery & {
	expand?: UsersGetAllExpand;
	search?: string;
	steamID?: string;
	steamIDs?: string[];
	userIDs?: number[];
	mapRank?: number;
};

export type UsersGetActivitiesQuery = Omit<ActivitiesGetQuery, 'userID'>;

export type UpdateFollowStatus = Pick<Follow, 'notifyOn'>;

export type UsersGetCreditsExpand = Array<'map' | 'info'>;

export type UsersGetCreditsQuery = PagedQuery & {
	expand?: UsersGetCreditsExpand;
};

type UserMapsBaseGetQuery = PagedQuery & { search?: string };

export type UserMapFavoritesGetExpand = Array<'info' | 'credits' | 'submitter' | 'personalBest'>;

export type UserMapFavoritesGetQuery = UserMapsBaseGetQuery & {
	expand?: UserMapFavoritesGetExpand;
};

export type DateString = string;

/**
 * Alias to distinguish a number supposed to represent a bit field.
 */
export type Flags<T extends number | undefined = undefined> = T extends void ? number : number & { __brand: T };

/**
 * Utility type to allow implementations of Prisma models to treat their `bigint` properties as `number`s.
 *
 * Excludes properties with key Exclude.
 *
 * Combined with NumberifyBigInt transformer to ensure we handle them safely.
 */
export type NumberifyBigInt<Model extends Record<string, any>, Exclude extends string | void = void> = {
	[K in keyof Model]: K extends Exclude
		? Model[K] // If excluded, do nothing
		: Model[K] extends bigint
			? number // Replace bigint with number
			: Model[K] extends bigint | null
				? number | null // Replace nullable bigint with nullable bigint
				: Model[K];
};

export type Vector = [number, number, number];
export type Vector2D = [number, number];
