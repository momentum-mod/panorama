/**
 * @file
 * !! Do not edit this file directly! This is generated from contents of the web
 * !! repository. If you really need to change something, make the change in the
 * !! web repository and run `npm run fetch-web`.
 *
 * Collection of constant values and types shared between the
 * https://github.com/momentum-mod/website monorepo and Panorama, containing:
 * - Types: TypeScript types and interfaces, primarily for modeling the DTOs
 *   (data transfer objects) returned by the backend.
 *   The C++ equivalents of these live in mom_api_models.h.
 * 	 See https://staging-api.momentum-mod.org/docs Schemas section, for
 * 	 detailed descriptions of every model/DTO.
 * - Enums: TypeScript enums for everything the backend uses.
 *   The C++ equivalents of these mostly live in mom_api_shareddefs.h.
 * - Maps: Readonly KV maps, usually associating enum values with extra data,
 *   e.g. gamemodes to their names, prefixes, icons etc...
 *   We use Maps instead of Objects since JavaScript object keys can only be
 *   strings or symbols, and most of our enum values are numbers.
 *
 * These are fetched from https://github.com/momentum-mod/website/tree/main/libs/constants
 * to maintain a single source of truth across our TypeScript projects. Things
 * unique to Panorama don't need to live here, they can be defined in other
 * files in this codebase.
 */
/* eslint-disable */
// Stub any broswer/node types we don't actually use:
type File = never;

export const STEAM_APPIDS = [669270, 1802710];

export function bspPath(key: string | number): string {
	return `maps/${key}.bsp`;
}

export function vmfsPath(key: string | number): string {
	return `maps/${key}_VMFs.zip`;
}

export function imgSmallPath(key: string): string {
	return `img/${key}-small.jpg`;
}

export function imgMediumPath(key: string): string {
	return `img/${key}-medium.jpg`;
}

export function imgLargePath(key: string): string {
	return `img/${key}-large.jpg`;
}

export function imgXlPath(key: string): string {
	return `img/${key}-xl.jpg`;
}

export function runPath(key: string | number | bigint): string {
	return `runs/${key}`;
}

export function mapListPath(type: FlatMapList, version: string | number): string {
	return `maplist/${type === FlatMapList.APPROVED ? 'approved' : 'submissions'}/${version}.dat`;
}

export function mapListDir(type: FlatMapList) {
	return type === FlatMapList.APPROVED ? 'maplist/approved/' : 'maplist/submissions/';
}

export function mapReviewAssetPath(key: string): string {
	return `mapreview/${key}`;
}

export const JWT_WEB_EXPIRY_TIME = '15m';
export const JWT_GAME_EXPIRY_TIME = '24h';
export const JWT_REFRESH_EXPIRY_TIME = '5d';

export const MAX_DAILY_REPORTS = 5;
export const MAX_MAP_IMAGES = 5;
export const MAX_BSP_SIZE = 300_000_000;
export const MAX_VMF_SIZE = 100_000_000;
export const MAX_MAP_IMAGE_SIZE = 10_000_000;
export const MAP_IMAGE_WIDTH = 2560;
export const MAP_IMAGE_HEIGHT = 1440;
export const MAX_CREDIT_DESCRIPTION_LENGTH = 64;
export const MAX_CHANGELOG_LENGTH = 1500;
export const MAX_REVIEW_LENGTH = 5000;
export const MAX_REVIEW_IMAGES = 20;
export const MAX_REVIEW_COMMENT_LENGTH = 1000;
export const MAX_TEST_INVITES = 20;
export const MIN_PUBLIC_TESTING_DURATION = 7 * 24 * 60 * 60 * 1000;
export const MAX_CREDITS_EXCEPT_TESTERS = 20;
export const MAX_BIO_LENGTH = 2000;
export const MIN_MAP_DESCRIPTION_LENGTH = 10;
export const MAX_MAP_DESCRIPTION_LENGTH = 1500;
export const MIN_MAP_NAME_LENGTH = 3;
export const MAX_MAP_NAME_LENGTH = 32; // Seems high but this is actually a constant in engine.
export const MAX_OPEN_MAP_SUBMISSIONS = 20;
export const MAX_MAP_SUGGESTION_COMMENT_LENGTH = 500;
export const PRE_SIGNED_URL_EXPIRE_TIME = 5 * 60;

// Very permissive regex for whenever exact criteria not avoilable online
const defaultRegex = /^[\w-]{3,40}$/;

export const SocialsData: Readonly<
	Record<keyof Socials, { icon: string; regex: RegExp; example: string; url: string }>
> = {
	Discord: {
		icon: 'discord',
		regex: /^[\w-]{2,32}$/,
		example: 'username',
		url: 'discordapp.com/users'
	},
	Twitch: {
		icon: 'twitch',
		regex: /^[\w-]{4,25}$/,
		example: 'username',
		url: 'twitch.tv'
	},
	YouTube: {
		icon: 'youtube',
		regex: /^@[\w-]{3,30}$/,
		example: '@username',
		url: 'youtube.com'
	},
	Github: {
		icon: 'github',
		regex: /^[\w-]{2,39}$/,
		example: 'username',
		url: 'github.com'
	},
	Twitter: {
		icon: 'twitter',
		regex: /^[\w-]{2,15}$/,
		example: 'username',
		url: 'twitter.com'
	},
	Mastodon: {
		icon: 'mastodon',
		regex: /^(?:@[\w-]+){2}\.[\w-]+$/,
		example: '@user@instance',
		// For any Mastodon instance `foo`, user `user`, user's instance `instance`,
		// https://foo/@user@instance redirects to https://instance/@user.
		// So just using the official instance works for everything.
		url: 'mastodon.social'
	},
	LinkedIn: {
		icon: 'linkedin',
		regex: defaultRegex,
		example: 'firstname-lastname-12345',
		url: 'linkedin.com/in'
	},
	Instagram: {
		icon: 'instagram',
		regex: defaultRegex, // Sequential underscores are allowed
		example: 'username',
		url: 'instagram.com'
	},
	Spotify: {
		icon: 'spotify',
		regex: defaultRegex, // Just randomly generated alphanumeric
		example: '21ahtj33ps3kiiet4sqq4pnra',
		url: 'open.spotify.com/user'
	},
	Patreon: {
		icon: 'patreon',
		regex: defaultRegex,
		example: 'username',
		url: 'patreon.com'
	},
	'Ko-fi': {
		icon: 'kofi',
		regex: defaultRegex,
		example: 'username',
		url: 'ko-fi.com'
	},
	Paypal: {
		icon: 'paypal',
		// Either email or @whatever
		regex: /^@[\w-]{3,30}$/,
		example: 'username (Must be a paypal.me profile)',
		url: 'paypal.me'
	}
};

export function steamAvatarUrl(id: string): string {
	return `https://avatars.cloudflare.steamstatic.com/${id}_full.jpg`;
}

// This is the specific key Steam uses for all missing avatars.
// They even kept it when migrating to Cloudflare!
export const STEAM_MISSING_AVATAR = 'fef49e7fa7e1997310d705b2a6158ff8dc1cdfeb';
export const STEAM_MISSING_AVATAR_URL = steamAvatarUrl(STEAM_MISSING_AVATAR);

export enum ActivityType {
	ALL = 0,
	MAP_UPLOADED = 1,
	MAP_APPROVED = 2,
	REVIEW_MADE = 3,
	PB_ACHIEVED = 4,
	WR_ACHIEVED = 5,
	REPORT_FILED = 6,
	USER_JOINED = 7
}

export enum AdminActivityType {
	USER_UPDATE = 0,
	USER_CREATE_PLACEHOLDER = 1,
	USER_MERGE = 2,
	USER_DELETE = 3,
	MAP_UPDATE = 4,
	MAP_CONTENT_DELETE = 5,
	REPORT_UPDATE = 6,
	REPORT_RESOLVE = 7,
	REVIEW_DELETED = 8,
	REVIEW_COMMENT_DELETED = 9
}

export enum Ban {
	LEADERBOARDS = 0b00001,
	ALIAS = 0b00010,
	AVATAR = 0b00100,
	BIO = 0b01000,
	MAP_SUBMISSION = 0b10000
}

// All valid (officially assigned) ISO 3166-1 Alpha-2 codes, scraped from Wikipedia
export enum ISOCountryCode {
	AD = 'Andorra',
	AE = 'United Arab Emirates',
	AF = 'Afghanistan',
	AG = 'Antigua and Barbuda',
	AI = 'Anguilla',
	AL = 'Albania',
	AM = 'Armenia',
	AO = 'Angola',
	AQ = 'Antarctica',
	AR = 'Argentina',
	AS = 'American Samoa',
	AT = 'Austria',
	AU = 'Australia',
	AW = 'Aruba',
	AX = 'Åland Islands',
	AZ = 'Azerbaijan',
	BA = 'Bosnia and Herzegovina',
	BB = 'Barbados',
	BD = 'Bangladesh',
	BE = 'Belgium',
	BF = 'Burkina Faso',
	BG = 'Bulgaria',
	BH = 'Bahrain',
	BI = 'Burundi',
	BJ = 'Benin',
	BL = 'Saint Barthélemy',
	BM = 'Bermuda',
	BN = 'Brunei Darussalam',
	BO = 'Bolivia',
	BQ = 'Bonaire',
	BR = 'Brazil',
	BS = 'Bahamas',
	BT = 'Bhutan',
	BV = 'Bouvet Island',
	BW = 'Botswana',
	BY = 'Belarus',
	BZ = 'Belize',
	CA = 'Canada',
	CC = 'Cocos (Keeling) Islands',
	CD = 'Congo',
	CF = 'Central African Republic',
	// eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values
	CG = 'Congo',
	CH = 'Switzerland',
	CI = 'Ivory Coast',
	CK = 'Cook Islands',
	CL = 'Chile',
	CM = 'Cameroon',
	CN = 'China',
	CO = 'Colombia',
	CR = 'Costa Rica',
	CU = 'Cuba',
	CV = 'Cabo Verde',
	CW = 'Curacao',
	CX = 'Christmas Island',
	CY = 'Cyprus',
	CZ = 'Czechia',
	DE = 'Germany',
	DJ = 'Djibouti',
	DK = 'Denmark',
	DM = 'Dominica',
	DO = 'Dominican Republic',
	DZ = 'Algeria',
	EC = 'Ecuador',
	EE = 'Estonia',
	EG = 'Egypt',
	EH = 'Western Sahara',
	ER = 'Eritrea',
	ES = 'Spain',
	ET = 'Ethiopia',
	FI = 'Finland',
	FJ = 'Fiji',
	FK = 'Falkland Islands (Malvinas)',
	FM = 'Federated States of Micronesia',
	FO = 'Faroe Islands',
	FR = 'France',
	GA = 'Gabon',
	GB = 'United Kingdom',
	GD = 'Grenada',
	GE = 'Georgia',
	GF = 'French Guiana',
	GG = 'Guernsey',
	GH = 'Ghana',
	GI = 'Gibraltar',
	GL = 'Greenland',
	GM = 'Gambia',
	GN = 'Guinea',
	GP = 'Guadeloupe',
	GQ = 'Equatorial Guinea',
	GR = 'Greece',
	GS = 'South Georgia and the South Sandwich Islands',
	GT = 'Guatemala',
	GU = 'Guam',
	GW = 'Guinea-Bissau',
	GY = 'Guyana',
	HK = 'Hong Kong',
	HM = 'Heard Island and McDonald Islands',
	HN = 'Honduras',
	HR = 'Croatia',
	HT = 'Haiti',
	HU = 'Hungary',
	ID = 'Indonesia',
	IE = 'Ireland',
	IL = 'Israel',
	IM = 'Isle of Man',
	IN = 'India',
	IO = 'British Indian Ocean Territory',
	IQ = 'Iraq',
	IR = 'Islamic Republic of Iran',
	IS = 'Iceland',
	IT = 'Italy',
	JE = 'Jersey',
	JM = 'Jamaica',
	JO = 'Jordan',
	JP = 'Japan',
	KE = 'Kenya',
	KG = 'Kyrgyzstan',
	KH = 'Cambodia',
	KI = 'Kiribati',
	KM = 'Comoros',
	KN = 'Saint Kitts and Nevis',
	KP = "Democratic People's Republic of Korea",
	KR = 'Korea',
	KW = 'Kuwait',
	KY = 'Cayman Islands',
	KZ = 'Kazakhstan',
	LA = "Lao People's Democratic Republic",
	LB = 'Lebanon',
	LC = 'Saint Lucia',
	LI = 'Liechtenstein',
	LK = 'Sri Lanka',
	LR = 'Liberia',
	LS = 'Lesotho',
	LT = 'Lithuania',
	LU = 'Luxembourg',
	LV = 'Latvia',
	LY = 'Libya',
	MA = 'Morocco',
	MC = 'Monaco',
	MD = 'Moldova',
	ME = 'Montenegro',
	MF = 'Saint Martin',
	MG = 'Madagascar',
	MH = 'Marshall Islands',
	MK = 'North Macedonia',
	ML = 'Mali',
	MM = 'Myanmar',
	MN = 'Mongolia',
	MO = 'Macao',
	MP = 'Northern Mariana Islands',
	MQ = 'Martinique',
	MR = 'Mauritania',
	MS = 'Montserrat',
	MT = 'Malta',
	MU = 'Mauritius',
	MV = 'Maldives',
	MW = 'Malawi',
	MX = 'Mexico',
	MY = 'Malaysia',
	MZ = 'Mozambique',
	NA = 'Namibia',
	NC = 'New Caledonia',
	NE = 'Niger',
	NF = 'Norfolk Island',
	NG = 'Nigeria',
	NI = 'Nicaragua',
	NL = 'Netherlands',
	NO = 'Norway',
	NP = 'Nepal',
	NR = 'Nauru',
	NU = 'Niue',
	NZ = 'New Zealand',
	OM = 'Oman',
	PA = 'Panama',
	PE = 'Peru',
	PF = 'French Polynesia',
	PG = 'Papua New Guinea',
	PH = 'Philippines',
	PK = 'Pakistan',
	PL = 'Poland',
	PM = 'Saint Pierre and Miquelon',
	PN = 'Pitcairn',
	PR = 'Puerto Rico',
	PS = 'Palestine',
	PT = 'Portugal',
	PW = 'Palau',
	PY = 'Paraguay',
	QA = 'Qatar',
	RE = 'Réunion',
	RO = 'Romania',
	RS = 'Serbia',
	RU = 'Russian Federation',
	RW = 'Rwanda',
	SA = 'Saudi Arabia',
	SB = 'Solomon Islands',
	SC = 'Seychelles',
	SD = 'Sudan',
	SE = 'Sweden',
	SG = 'Singapore',
	SH = 'Saint Helena',
	SI = 'Slovenia',
	SJ = 'Svalbard and Jan Mayen',
	SK = 'Slovakia',
	SL = 'Sierra Leone',
	SM = 'San Marino',
	SN = 'Senegal',
	SO = 'Somalia',
	SR = 'Suriname',
	SS = 'South Sudan',
	ST = 'Sao Tome and Principe',
	SV = 'El Salvador',
	SX = 'Sint Maarten',
	SY = 'Syrian Arab Republic',
	SZ = 'Eswatini',
	TC = 'Turks and Caicos Islands',
	TD = 'Chad',
	TF = 'French Southern Territories',
	TG = 'Togo',
	TH = 'Thailand',
	TJ = 'Tajikistan',
	TK = 'Tokelau',
	TL = 'Timor-Leste',
	TM = 'Turkmenistan',
	TN = 'Tunisia',
	TO = 'Tonga',
	TR = 'Turkey',
	TT = 'Trinidad and Tobago',
	TV = 'Tuvalu',
	TW = 'Taiwan',
	TZ = 'Tanzania',
	UA = 'Ukraine',
	UG = 'Uganda',
	UM = 'United States Minor Outlying Islands',
	US = 'United States of America',
	UY = 'Uruguay',
	UZ = 'Uzbekistan',
	VA = 'Holy See',
	VC = 'Saint Vincent and the Grenadines',
	VE = 'Venezuela',
	VG = 'British Virgin Islands',
	VI = 'U.S. Virgin Islands',
	VN = 'Viet Nam',
	VU = 'Vanuatu',
	WF = 'Wallis and Futuna',
	WS = 'Samoa',
	YE = 'Yemen',
	YT = 'Mayotte',
	ZA = 'South Africa',
	ZM = 'Zambia',
	ZW = 'Zimbabwe'
}

export enum DefragModifiers {
	HASTE = 1 << 0,
	SLICK = 1 << 1,
	DAMAGEBOOST = 1 << 2,
	ROCKETS = 1 << 3,
	PLASMA = 1 << 4,
	BFG = 1 << 5
}

export enum FlatMapList {
	APPROVED = 'approved',
	SUBMISSION = 'submission'
}

/**
 * All the modes available in Momentum.
 */
export enum Gamemode {
	SURF = 1,
	BHOP = 2,
	BHOP_HL1 = 3,
	CLIMB_MOM = 4,
	CLIMB_KZT = 5,
	CLIMB_16 = 6,
	RJ = 7,
	SJ = 8,
	AHOP = 9,
	CONC = 10,
	DEFRAG_CPM = 11,
	DEFRAG_VQ3 = 12,
	DEFRAG_VTG = 13
}

/**
 * The outer categories that gamemodes are grouped into.
 */
export enum GamemodeCategory {
	SURF = 1,
	BHOP = 2,
	CLIMB = 3,
	RJ = 4,
	SJ = 5,
	AHOP = 6,
	CONC = 7,
	DEFRAG = 8
}

export const GamemodeCategoryToGamemode = new Map<GamemodeCategory, Gamemode[]>([
	[GamemodeCategory.SURF, [Gamemode.SURF]],
	[GamemodeCategory.BHOP, [Gamemode.BHOP, Gamemode.BHOP_HL1]],
	[GamemodeCategory.CLIMB, [Gamemode.CLIMB_MOM, Gamemode.CLIMB_KZT, Gamemode.CLIMB_16]],
	[GamemodeCategory.RJ, [Gamemode.RJ]],
	[GamemodeCategory.SJ, [Gamemode.SJ]],
	[GamemodeCategory.AHOP, [Gamemode.AHOP]],
	[GamemodeCategory.CONC, [Gamemode.CONC]],
	[GamemodeCategory.DEFRAG, [Gamemode.DEFRAG_CPM, Gamemode.DEFRAG_VQ3, Gamemode.DEFRAG_VTG]]
]);

export const GamemodeToGamemodeCategory = new Map<Gamemode, GamemodeCategory>([
	[Gamemode.SURF, GamemodeCategory.SURF],
	[Gamemode.BHOP, GamemodeCategory.BHOP],
	[Gamemode.BHOP_HL1, GamemodeCategory.BHOP],
	[Gamemode.CLIMB_MOM, GamemodeCategory.CLIMB],
	[Gamemode.CLIMB_KZT, GamemodeCategory.CLIMB],
	[Gamemode.CLIMB_16, GamemodeCategory.CLIMB],
	[Gamemode.RJ, GamemodeCategory.RJ],
	[Gamemode.SJ, GamemodeCategory.SJ],
	[Gamemode.AHOP, GamemodeCategory.AHOP],
	[Gamemode.CONC, GamemodeCategory.CONC],
	[Gamemode.DEFRAG_CPM, GamemodeCategory.DEFRAG],
	[Gamemode.DEFRAG_VQ3, GamemodeCategory.DEFRAG],
	[Gamemode.DEFRAG_VTG, GamemodeCategory.DEFRAG]
]);

/**
 * All the image formats we support in different places.
 *
 * We could support more images if we really wanted, but WebP really isn't
 * that impressive vs mozjpeg jpegs, and we use mozjpeg to compress submitted
 * MapImage PNGs, so not much point bothering. Also fuck Google.
 */
export enum ImageType {
	JPG,
	PNG
}

// Enum is string based to make using as object keys easier
export enum KillswitchType {
	NEW_SIGNUPS = 'NEW_SIGNUPS',
	RUN_SUBMISSION = 'RUN_SUBMISSION',
	MAP_SUBMISSION = 'MAP_SUBMISSION',
	MAP_REVIEWS = 'MAP_REVIEWS'
}

export enum LeaderboardType {
	RANKED = 0,
	UNRANKED = 1,
	HIDDEN = 2,
	IN_SUBMISSION = 3
}

export enum MapCreditType {
	/* Contributed significant work to the map */
	AUTHOR = 0,
	/* Did minor work on the map */
	CONTRIBUTOR = 1,
	/* Tested the map during development, or submitted reviews during map
	 * submission testing phases */
	TESTER = 2,
	/* Any miscellaneous contributions, e.g. donations, encouragement etc. */
	SPECIAL_THANKS = 3
}

export enum MapStatus {
	/* Completed submission and is available to everyone */
	APPROVED = 0,
	/* Available in the Beta tab to users with an accepted MapTestingInvite */
	PRIVATE_TESTING = 1,
	/* Awaiting approval from a REVIEWER before it can be made public */
	CONTENT_APPROVAL = 2,
	/* Available to all users in the Beta tab*/
	PUBLIC_TESTING = 3,
	/* Awaiting final approval from a MODERATOR/ADMIN */
	FINAL_APPROVAL = 4,
	/* Anything that has been disabled for some reason, such as rejected map
  submissions, maps with critical bugs (that may often be fixed and re-enabled),
  maps with a DMCA claim, etc. */
	DISABLED = 5
}

export const MapStatuses = Object.freeze({
	IN_SUBMISSION: [
		MapStatus.PRIVATE_TESTING,
		MapStatus.PUBLIC_TESTING,
		MapStatus.CONTENT_APPROVAL,
		MapStatus.FINAL_APPROVAL
	],
	PRIVATE: [MapStatus.PRIVATE_TESTING, MapStatus.CONTENT_APPROVAL]
});

export enum MapSubmissionType {
	ORIGINAL = 0,
	PORT = 1,
	SPECIAL = 2
}

/* eslint @typescript-eslint/naming-convention: 0 */
/**
 * Enum of all possible tags.
 *
 * Tags should *never* be removed - if we need to disable a tag in the
 * future, just remove it global tags and gamemode tags.
 *
 * Breaking naming convention, using casing that lets us translate to English
 * strings easily.
 *
 * - If tag name starts with a number, prefix it with `_Num`.
 * - If tag name contains a hyphen, use `__`
 *
 * For example, `_Num2__Way_Sym` becomes `2-Way Sym`.
 *
 * After adding tags, you need to run
 * ```
 * nx run scripts:maptags-poeditor
 * ```
 * which writes a JSON file to cwd, then import that file into POEditor, with
 * "Also import translations to a language" set to English. POEditor will not
 * overwrite existing translations.
 */
export enum MapTag {
	Portals = 1,
	Multiroute = 2,
	Low_Grav = 3,
	Gimmick = 4,
	Endurance = 5,
	Collectibles = 6,
	Anti_Grav = 7,
	Moving_Surfaces = 8,
	Unit = 9,
	Tech = 10,
	Spins = 11,
	Booster = 12,
	Headsurf = 13,
	Bhop = 14,
	Increased_Maxvel = 15,
	Fall = 16,
	Rampstrafe = 17,
	Headcheck = 18,
	Strafe = 19,
	Fly = 20,
	Surf = 21,
	Weapons = 22,
	Spikes = 23,
	Slopes = 24,
	Misaligned_Teleporters = 25,
	Climb = 26,
	Ladder = 27,
	Forced_Bhop = 28,
	HL2 = 29,
	Speed_Control = 30,
	Displacements = 31,
	Prec = 32,
	Juggle = 33,
	Juggleprec = 34,
	Handheld = 35,
	Sync = 36,
	Wallpogo = 37,
	Speedshot = 38,
	Bounce = 39,
	Bouncehop = 40,
	Jurf = 41,
	Edgebug = 42,
	Wallshot = 43,
	Phase = 44,
	Prefire = 45,
	Buttons = 46,
	Limited_Ammo = 47,
	Water = 48,
	Teledoor = 49,
	Airpogo = 50,
	Vert = 51,
	Rollerpogo = 52,
	Downair = 53,
	Slanted_Walls = 54,
	Air_Jump = 55,
	Rocket_Launcher = 56,
	Grenade_Launcher = 57,
	Plasma_Gun = 58,
	BFG = 59,
	Combo = 60,
	Haste = 61,
	Damageboost = 62,
	Trick = 63,
	Slick = 64,
	Torture = 65,
	Overbounce = 66,
	LG_Climb = 67,
	Rocket_Stack = 68,
	Telehop = 69,
	Slide = 70,
	Longjump = 71,
	Ceilingsmash = 72,
	CS_Practice = 73,
	Single_Hop = 74,
	Holes = 75,
	Angle_Snipe = 76,
	Low_Speed = 77,
	Fast_Paced = 78,
	Progressive_Difficulty = 79,
	Rocket_Spam = 80,
	Strafe_Pads = 81,
	Lightning_Gun = 82,
	_Num2__Way_Sym = 83,
	_Num4__Way_Sym = 84,
	Staged__Linear = 85,
	Funkyboost = 86,
	Mixed = 87
}

export enum MapTestInviteState {
	UNREAD = 0,
	ACCEPTED = 1,
	DECLINED = 2
}

export enum ReportCategory {
	OTHER = 0,
	INAPPROPRIATE_CONTENT = 1,
	PLAGIARISM = 2,
	SPAM = 3
}

export enum ReportType {
	USER_PROFILE_REPORT = 0,
	MAP_REPORT = 1,
	MAP_COMMENT_REPORT = 2
}

export enum Role {
	ADMIN = 0b00000001,
	MODERATOR = 0b00000010,
	VERIFIED = 0b00000100,
	PLACEHOLDER = 0b00001000,
	DELETED = 0b00010000,
	REVIEWER = 0b00100000,
	MAPPER = 0b01000000,
	PORTER = 0b10000000
}

export const CombinedRoles = Object.freeze({
	MOD_OR_ADMIN: Role.MODERATOR | Role.ADMIN,
	REVIEWER_AND_ABOVE: Role.REVIEWER | Role.MODERATOR | Role.ADMIN,
	MAPPER_OR_PORTER: Role.MAPPER | Role.PORTER,
	MAPPER_AND_ABOVE: Role.MAPPER | Role.PORTER | Role.REVIEWER | Role.MODERATOR | Role.ADMIN
});

export enum RunValidationErrorType {
	BAD_TIMESTAMPS = 0,
	BAD_REPLAY_FILE = 1,
	BAD_META = 2,
	INVALID_STATS = 3,
	OUT_OF_SYNC = 4,
	UNSUPPORTED_MODE = 5,
	FUCKY_BEHAVIOUR = 6,
	INTERNAL_ERROR = 7
}

export const RunValidationErrorMessages: Record<RunValidationErrorType, string> = {
	[RunValidationErrorType.BAD_TIMESTAMPS]: 'run timestamps were misordered',
	[RunValidationErrorType.BAD_REPLAY_FILE]: 'invalid replay file',
	[RunValidationErrorType.BAD_META]: 'invalid metadata',
	[RunValidationErrorType.INVALID_STATS]: 'invalid stats',
	[RunValidationErrorType.OUT_OF_SYNC]: 'replay data out of sync with submission times',
	[RunValidationErrorType.UNSUPPORTED_MODE]: 'this mode is not currently supported',
	[RunValidationErrorType.FUCKY_BEHAVIOUR]: 'unusual behaviour in replay',
	[RunValidationErrorType.INTERNAL_ERROR]: 'an internal server error occurred'
};

export class RunValidationError extends Error {
	code: RunValidationErrorType;

	constructor(type: RunValidationErrorType) {
		super(RunValidationErrorMessages[type]);
		this.code = type;
	}
}

export enum SteamGame {
	CSS = 240,
	TF2 = 440,
	PORTAL2 = 620,
	CSGO = 730
}

export enum Style {
	NONE = 0,
	HSW = 1 << 0,
	SW = 1 << 1,
	BW = 1 << 2
}

export enum TrackType {
	MAIN = 0,
	STAGE = 1,
	BONUS = 2
}

export const TrackTypeName: ReadonlyMap<TrackType, string> = new Map([
	[TrackType.MAIN, 'Main'],
	[TrackType.STAGE, 'Stage'],
	[TrackType.BONUS, 'Bonus']
]);

export const BanNames: ReadonlyMap<Ban, string> = new Map([
	[Ban.LEADERBOARDS, 'Leaderboards'],
	[Ban.ALIAS, 'Alias'],
	[Ban.AVATAR, 'Avatar'],
	[Ban.BIO, 'Bio'],
	[Ban.MAP_SUBMISSION, 'Map submission']
]);

export const GamemodeCategories: ReadonlyMap<GamemodeCategory, Array<Gamemode>> = new Map([
	[GamemodeCategory.SURF, [Gamemode.SURF]],
	[GamemodeCategory.BHOP, [Gamemode.BHOP, Gamemode.BHOP_HL1]],
	[GamemodeCategory.RJ, [Gamemode.RJ]],
	[GamemodeCategory.SJ, [Gamemode.SJ]],
	[GamemodeCategory.AHOP, [Gamemode.AHOP]],
	[GamemodeCategory.CONC, [Gamemode.CONC]],
	[GamemodeCategory.DEFRAG, [Gamemode.DEFRAG_CPM, Gamemode.DEFRAG_VQ3, Gamemode.DEFRAG_VTG]],
	[GamemodeCategory.CLIMB, [Gamemode.CLIMB_KZT, Gamemode.CLIMB_MOM, Gamemode.CLIMB_16]]
]);

// See mom_system_gamemode.h for CPP version of similar properties
export interface GamemodeInfoProperties {
	category: GamemodeCategory;
	name: string;
	id: string;
	prefix: string;
	icon: string;
}

export const GamemodeInfo: ReadonlyMap<Gamemode, GamemodeInfoProperties> = new Map([
	[
		Gamemode.SURF,
		{
			category: GamemodeCategory.SURF,
			name: 'Surf',
			id: 'surf',
			prefix: 'surf',
			icon: 'surf'
		}
	],
	[
		Gamemode.BHOP,
		{
			category: GamemodeCategory.BHOP,
			name: 'Bhop',
			id: 'bhop',
			prefix: 'bhop',
			icon: 'bhop'
		}
	],
	[
		Gamemode.BHOP_HL1,
		{
			category: GamemodeCategory.BHOP,
			name: 'Bhop (HL1)',
			id: 'bhop_hl',
			prefix: 'bhophl',
			icon: 'bhop'
		}
	],
	[
		Gamemode.CLIMB_MOM,
		{
			category: GamemodeCategory.CLIMB,
			name: 'Climb (Momentum)',
			id: 'kz_mom',
			prefix: 'kz',
			icon: 'climb'
		}
	],
	[
		Gamemode.CLIMB_KZT,
		{
			category: GamemodeCategory.CLIMB,
			name: 'Climb (KZT)',
			id: 'kz_kzt',
			prefix: 'kzt',
			icon: 'climb'
		}
	],
	[
		Gamemode.CLIMB_16,
		{
			category: GamemodeCategory.CLIMB,
			name: 'Climb (1.6)',
			id: 'kz_16',
			prefix: 'kz16',
			icon: 'climb'
		}
	],
	[
		Gamemode.RJ,
		{
			category: GamemodeCategory.RJ,
			name: 'Rocket Jump',
			id: 'rj',
			prefix: 'rj',
			icon: 'rj'
		}
	],
	[
		Gamemode.SJ,
		{
			category: GamemodeCategory.SJ,
			name: 'Sticky Jump',
			id: 'sj',
			prefix: 'sj',
			icon: 'sj'
		}
	],
	[
		Gamemode.AHOP,
		{
			category: GamemodeCategory.AHOP,
			name: 'Ahop',
			id: 'ahop',
			prefix: 'ahop',
			icon: 'ahop'
		}
	],
	[
		Gamemode.CONC,
		{
			category: GamemodeCategory.CONC,
			name: 'Conc',
			id: 'conc',
			prefix: 'conc',
			icon: 'conc'
		}
	],
	[
		Gamemode.DEFRAG_CPM,
		{
			category: GamemodeCategory.DEFRAG,
			name: 'Defrag (CPM)',
			id: 'df_cpm',
			prefix: 'df',
			icon: 'defrag'
		}
	],
	[
		Gamemode.DEFRAG_VQ3,
		{
			category: GamemodeCategory.DEFRAG,
			name: 'Defrag (VQ3)',
			id: 'df_vq3',
			prefix: 'df',
			icon: 'defrag'
		}
	],
	[
		Gamemode.DEFRAG_VTG,
		{
			category: GamemodeCategory.DEFRAG,
			name: 'Defrag (Vintage)',
			id: 'df_vtg',
			prefix: 'df',
			icon: 'defrag'
		}
	]
]);

// Silly little system for passing whole categories into this structure, rather
// than each individual gamemode, but structured so we could do single gamemodes
// in future if needed. Lots of these are singleton categories but using them
// for future-proofing, for example 100t surf would have the exact same rules
// as regular surf.
// JAVASCRIPT PLEASE ADD CONSTEXPR!!!
const G = Gamemode; //
const GC = GamemodeCategory;
const Cats = (...gcs: GamemodeCategory[]) => gcs.flatMap((gc) => GamemodeCategories.get(gc)!);

/**
 * A non-reflexive map of gamemodes and collections of gamemodes they can
 * *never* have compatibile leaderboards for.
 *
 * For example, there's *never* a possible case
 * where a surf leaderboard should also have a bhop leaderboard, that'd just be
 * jank 100-tick surf.
 *
 * Note the non-reflexivity, you might have a surf map that's worth a
 * leaderboard in ahop (e.g. utopia), but a ahop map would never have a surf
 * leaderboard, since that'd just be bhop with worse settings.
 */
export const IncompatibleGamemodes: ReadonlyMap<Gamemode, ReadonlySet<Gamemode>> = new Map(
	[
		[G.SURF, [Cats(GC.BHOP, GC.CLIMB)]],
		[G.BHOP, [Cats(GC.SURF, GC.CLIMB)]],
		[G.BHOP_HL1, [Cats(GC.SURF, GC.CLIMB)]],
		[G.CLIMB_MOM, [Cats(GC.SURF, GC.BHOP)]],
		[G.CLIMB_KZT, [Cats(GC.SURF, GC.BHOP)]],
		[G.CLIMB_16, [Cats(GC.SURF, GC.BHOP)]],
		[G.RJ, [Cats(GC.SURF, GC.CLIMB, GC.BHOP, GC.AHOP)]],
		[G.SJ, [Cats(GC.SURF, GC.CLIMB, GC.BHOP, GC.AHOP)]],
		[G.AHOP, [Cats(GC.SURF, GC.CLIMB)]],
		[G.CONC, [Cats(GC.SURF, GC.CLIMB, GC.BHOP, GC.AHOP)]],
		[G.DEFRAG_CPM, [Cats(GC.SURF, GC.CLIMB)]],
		[G.DEFRAG_VQ3, [Cats(GC.SURF, GC.CLIMB)]],
		[G.DEFRAG_VTG, [Cats(GC.SURF, GC.CLIMB)]]
	].map(([k, v]) => [k as Gamemode, new Set((v as [Gamemode | Gamemode[]]).flat())])
);

export const LeaderboardTypeName: ReadonlyMap<LeaderboardType, string> = new Map([
	[LeaderboardType.RANKED, 'Ranked'],
	[LeaderboardType.UNRANKED, 'Unranked'],
	[LeaderboardType.HIDDEN, 'Hidden']
]);

export const MapCreditNames: ReadonlyMap<MapCreditType, string> = new Map([
	[MapCreditType.AUTHOR, 'Authors'],
	[MapCreditType.CONTRIBUTOR, 'Contributors'],
	[MapCreditType.TESTER, 'Testers'],
	[MapCreditType.SPECIAL_THANKS, 'Special Thanks']
]);

/**
 * Stores what changes between map statuses are allowed by what users
 *
 * In table form:
 *
 * | From(Down), To(Across) | Approved | Private Testing | Content Approval | Public Testing | Final Approval | Disabled |
 * | ---------------------- | -------- | --------------- | ---------------- | -------------- | -------------- | -------- |
 * | Approved               |          |                 |                  |                |                | AM       |
 * | Private Testing        |          |                 | S                |                |                | AM       |
 * | Content Approval       |          | S               |                  | RAM            | AM             | AM       |
 * | Public Testing         |          |                 | AM               |                | S              | AM       |
 * | Final Approval         | AM       |                 |                  | S              |                | AM       |
 * | Disabled               | A†       | A               | A                | A              | A              |          |
 *
 * † Admins can only move from disabled to approved if the map has been approved once in the past
 */
export const MapStatusChangeRules: ReadonlyArray<{ from: MapStatus; to: MapStatus; roles: Array<Role | 'submitter'> }> =
	[
		{ from: MapStatus.APPROVED, to: MapStatus.APPROVED, roles: [] },
		{ from: MapStatus.APPROVED, to: MapStatus.PRIVATE_TESTING, roles: [] },
		{ from: MapStatus.APPROVED, to: MapStatus.CONTENT_APPROVAL, roles: [] },
		{ from: MapStatus.APPROVED, to: MapStatus.PUBLIC_TESTING, roles: [] },
		{ from: MapStatus.APPROVED, to: MapStatus.FINAL_APPROVAL, roles: [] },
		{ from: MapStatus.APPROVED, to: MapStatus.DISABLED, roles: [Role.ADMIN, Role.MODERATOR] },

		{ from: MapStatus.PRIVATE_TESTING, to: MapStatus.APPROVED, roles: [] },
		{ from: MapStatus.PRIVATE_TESTING, to: MapStatus.PRIVATE_TESTING, roles: [] },
		{ from: MapStatus.PRIVATE_TESTING, to: MapStatus.CONTENT_APPROVAL, roles: ['submitter'] },
		{ from: MapStatus.PRIVATE_TESTING, to: MapStatus.PUBLIC_TESTING, roles: [] },
		{ from: MapStatus.PRIVATE_TESTING, to: MapStatus.FINAL_APPROVAL, roles: [] },
		{ from: MapStatus.PRIVATE_TESTING, to: MapStatus.DISABLED, roles: [Role.ADMIN, Role.MODERATOR] },

		{ from: MapStatus.CONTENT_APPROVAL, to: MapStatus.APPROVED, roles: [] },
		{ from: MapStatus.CONTENT_APPROVAL, to: MapStatus.PRIVATE_TESTING, roles: ['submitter'] },
		{ from: MapStatus.CONTENT_APPROVAL, to: MapStatus.CONTENT_APPROVAL, roles: [] },
		{
			from: MapStatus.CONTENT_APPROVAL,
			to: MapStatus.PUBLIC_TESTING,
			roles: [Role.REVIEWER, Role.ADMIN, Role.MODERATOR]
		},
		{ from: MapStatus.CONTENT_APPROVAL, to: MapStatus.FINAL_APPROVAL, roles: [Role.ADMIN, Role.MODERATOR] },
		{ from: MapStatus.CONTENT_APPROVAL, to: MapStatus.DISABLED, roles: [Role.ADMIN, Role.MODERATOR] },

		{ from: MapStatus.PUBLIC_TESTING, to: MapStatus.APPROVED, roles: [] },
		{ from: MapStatus.PUBLIC_TESTING, to: MapStatus.PRIVATE_TESTING, roles: [] },
		{ from: MapStatus.PUBLIC_TESTING, to: MapStatus.CONTENT_APPROVAL, roles: [Role.ADMIN, Role.MODERATOR] },
		{ from: MapStatus.PUBLIC_TESTING, to: MapStatus.PUBLIC_TESTING, roles: [] },
		{
			from: MapStatus.PUBLIC_TESTING,
			to: MapStatus.FINAL_APPROVAL,
			roles: ['submitter', Role.ADMIN, Role.MODERATOR]
		},
		{ from: MapStatus.PUBLIC_TESTING, to: MapStatus.DISABLED, roles: [Role.ADMIN, Role.MODERATOR] },

		{ from: MapStatus.FINAL_APPROVAL, to: MapStatus.APPROVED, roles: [Role.ADMIN, Role.MODERATOR] },
		{ from: MapStatus.FINAL_APPROVAL, to: MapStatus.PRIVATE_TESTING, roles: [] },
		{ from: MapStatus.FINAL_APPROVAL, to: MapStatus.CONTENT_APPROVAL, roles: [] },
		{ from: MapStatus.FINAL_APPROVAL, to: MapStatus.PUBLIC_TESTING, roles: ['submitter'] },
		{ from: MapStatus.FINAL_APPROVAL, to: MapStatus.FINAL_APPROVAL, roles: [] },
		{ from: MapStatus.FINAL_APPROVAL, to: MapStatus.DISABLED, roles: [Role.ADMIN, Role.MODERATOR] },

		{ from: MapStatus.DISABLED, to: MapStatus.APPROVED, roles: [Role.ADMIN] },
		{ from: MapStatus.DISABLED, to: MapStatus.PRIVATE_TESTING, roles: [Role.ADMIN] },
		{ from: MapStatus.DISABLED, to: MapStatus.CONTENT_APPROVAL, roles: [Role.ADMIN] },
		{ from: MapStatus.DISABLED, to: MapStatus.PUBLIC_TESTING, roles: [Role.ADMIN] },
		{ from: MapStatus.DISABLED, to: MapStatus.FINAL_APPROVAL, roles: [Role.ADMIN] },
		{ from: MapStatus.DISABLED, to: MapStatus.DISABLED, roles: [] }
	];

export const MapStatusName: ReadonlyMap<MapStatus, string> = new Map([
	[MapStatus.APPROVED, 'Approved'],
	[MapStatus.PRIVATE_TESTING, 'Private Testing'],
	[MapStatus.CONTENT_APPROVAL, 'Content Approval'],
	[MapStatus.PUBLIC_TESTING, 'Public Testing'],
	[MapStatus.FINAL_APPROVAL, 'Final Approval'],
	[MapStatus.DISABLED, 'Disabled']
]);

export const GlobalTags = [
	MapTag.Portals,
	MapTag.Multiroute,
	MapTag.Low_Grav,
	MapTag.Gimmick,
	MapTag.Endurance,
	MapTag.Collectibles,
	MapTag.Anti_Grav,
	MapTag.Moving_Surfaces,
	MapTag.Increased_Maxvel,
	MapTag.Progressive_Difficulty,
	MapTag.Mixed
];

export const GamemodeTags = {
	[GamemodeCategory.SURF]: [
		MapTag.Unit,
		MapTag.Tech,
		MapTag.Spins,
		MapTag.Booster,
		MapTag.Headsurf,
		MapTag.Bhop,
		MapTag.Fall,
		MapTag.Slide,
		MapTag.Rampstrafe,
		MapTag.Headcheck,
		MapTag.Angle_Snipe,
		MapTag.Low_Speed,
		MapTag.Fast_Paced,
		MapTag._Num2__Way_Sym,
		MapTag._Num4__Way_Sym,
		MapTag.Staged__Linear
	],
	[GamemodeCategory.BHOP]: [
		MapTag.Strafe,
		MapTag.Tech,
		MapTag.Fly,
		MapTag.Surf,
		MapTag.Weapons,
		MapTag.Spins,
		MapTag.Spikes,
		MapTag.Slopes,
		MapTag.Misaligned_Teleporters,
		MapTag.Climb,
		MapTag.Booster,
		MapTag.Fast_Paced,
		MapTag.Forced_Bhop
	],
	[GamemodeCategory.CLIMB]: [
		MapTag.Ladder,
		MapTag.Bhop,
		MapTag.Slide,
		MapTag.Longjump,
		MapTag.Ceilingsmash,
		MapTag.CS_Practice,
		MapTag.Single_Hop
	],
	[GamemodeCategory.RJ]: [
		MapTag.Sync,
		MapTag.Wallpogo,
		MapTag.Speedshot,
		MapTag.Bounce,
		MapTag.Bouncehop,
		MapTag.Jurf,
		MapTag.Edgebug,
		MapTag.Wallshot,
		MapTag.Phase,
		MapTag.Prefire,
		MapTag.Buttons,
		MapTag.Limited_Ammo,
		MapTag.Water,
		MapTag.Teledoor
	],
	[GamemodeCategory.SJ]: [
		MapTag.Airpogo,
		MapTag.Wallpogo,
		MapTag.Vert,
		MapTag.Limited_Ammo,
		MapTag.Phase,
		MapTag.Downair,
		MapTag.Slanted_Walls,
		MapTag.Teledoor,
		MapTag.Holes
	],
	[GamemodeCategory.AHOP]: [
		MapTag.HL2,
		MapTag.Speed_Control,
		MapTag.Displacements,
		MapTag.Surf,
		MapTag.Low_Speed,
		MapTag.Fast_Paced
	],
	[GamemodeCategory.CONC]: [MapTag.Prec, MapTag.Juggle, MapTag.Limited_Ammo, MapTag.Handheld, MapTag.Juggleprec],
	[GamemodeCategory.DEFRAG]: [
		MapTag.Strafe,
		MapTag.Rocket_Launcher,
		MapTag.Grenade_Launcher,
		MapTag.Plasma_Gun,
		MapTag.BFG,
		MapTag.Combo,
		MapTag.Haste,
		MapTag.Damageboost,
		MapTag.Climb,
		MapTag.Trick,
		MapTag.Slick,
		MapTag.Torture,
		MapTag.Overbounce,
		MapTag.LG_Climb,
		MapTag.Rocket_Stack,
		MapTag.Buttons,
		MapTag.Air_Jump,
		MapTag.Rocket_Spam,
		MapTag.Strafe_Pads,
		MapTag.Lightning_Gun,
		MapTag.Staged__Linear,
		MapTag.Funkyboost
	]
} satisfies Record<GamemodeCategory, number[]>;

// We could add support for individual subcategories (Gamemodes), but don't
// have a single example of one yet.

/** Get the i18n token for a map tag */
export function mapTagToken(tag: MapTag): string {
	return 'MapTag_' + MapTag[tag];
}

/** Get the English name of a map tag */
export function mapTagEnglishName(tag: MapTag): string {
	return MapTag[tag].replace('__', '-').replace('_Num', '').replace('_', ' ');
}

export const MapTags = new Map(
	GamemodeToGamemodeCategory.entries().map(([gamemode, category]) => [
		gamemode,
		[...GlobalTags, ...GamemodeTags[category]].sort((a, b) =>
			// Lexicograpic sort by *ENGLISH* name - Panorama will want to sort by
			// localized names!
			MapTag[a] > MapTag[b] ? 1 : -1
		)
	])
);

export const RoleNames: ReadonlyMap<Role, string> = new Map([
	[Role.ADMIN, 'Admin'],
	[Role.MODERATOR, 'Moderator'],
	[Role.MAPPER, 'Mapper'],
	[Role.PORTER, 'Porter'],
	[Role.DELETED, 'Deleted'],
	[Role.PLACEHOLDER, 'Placeholder'],
	[Role.REVIEWER, 'Reviewer'],
	[Role.VERIFIED, 'Verified']
]);

export const SteamGamesNames: ReadonlyMap<SteamGame, string> = new Map([
	[SteamGame.CSS, 'Counter-Strike: Source'],
	[SteamGame.TF2, 'Team Fortress 2'],
	[SteamGame.PORTAL2, 'Portal 2'],
	[SteamGame.CSGO, 'Counter-Strike: Global Offensive']
]);

export const SteamGamesImages: ReadonlyMap<SteamGame, string> = new Map([
	[SteamGame.CSS, '/assets/images/games-logos/css.png'],
	[SteamGame.TF2, '/assets/images/games-logos/tf2.png'],
	[SteamGame.PORTAL2, '/assets/images/games-logos/portal2.png'],
	[SteamGame.CSGO, '/assets/images/games-logos/csgo.png']
]);

/**
 * The tick intervals (inverse of tickrate) each gamemode uses. In Source
 * they're floats (32-bit), so take care to use f32 rounded values in JS.
 *
 * @see (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround)
 *
 * | Tick Rate | Tick Interval |
 * |-----------|---------------|
 * | 66        | 0.015         |
 * | 100       | 0.01          |
 * | 125       | 0.008         |
 * | 128       | 0.0078125     |
 */
export const TickIntervals: ReadonlyMap<Gamemode, float> = new Map([
	[Gamemode.AHOP, Math.fround(0.015)],
	[Gamemode.BHOP, Math.fround(0.01)],
	[Gamemode.BHOP_HL1, Math.fround(0.004)],
	[Gamemode.CLIMB_MOM, Math.fround(0.01)],
	[Gamemode.CLIMB_KZT, Math.fround(0.01)],
	[Gamemode.CLIMB_16, Math.fround(0.01)],
	[Gamemode.CONC, Math.fround(0.01)],
	[Gamemode.DEFRAG_CPM, Math.fround(0.008)],
	[Gamemode.DEFRAG_VQ3, Math.fround(0.008)],
	[Gamemode.DEFRAG_VTG, Math.fround(0.008)],
	[Gamemode.RJ, Math.fround(0.015)],
	[Gamemode.SJ, Math.fround(0.015)],
	[Gamemode.SURF, Math.fround(0.015)]
]);

export const ISO_8601_REGEXP =
	/[+-]?\d{4}(-[01]\d(-[0-3]\d(T[0-2]\d:[0-5]\d:?([0-5]\d(\.\d+)?)?[+-][0-2]\d:[0-5]\dZ?)?)?)?/;

export const MAP_NAME_REGEXP = /^[a-z][\d_a-z-]+$/;

// Checks user alias for whitespace including braille whitespace which
// javascript's regex engine doesn't include in \s.
export const NON_WHITESPACE_REGEXP = /^(?![\s\u2800]*$).+/;

export const YOUTUBE_ID_REGEXP = /^[\w-_]{11}$/;

// Collection of models used throughout the codebase, as well as in Panorama.
//
// We don't use Prisma types anymore, since
// - Data exported from the backend often has small difference from how it's
//   stored in DB.
// - Prisma schemas *still* can't specific types for Json values.
// - Prisma types are absurdly complicated, and slow down the TypeScript
//   language server.
// - Fuck Prisma.

/* eslint @typescript-eslint/no-namespace: 0 */

//#region User

export interface User {
	id: number;
	steamID: string;
	alias: string;
	avatarURL: string;
	country: string | null;
	roles: Flags<Role>;
	bans: Flags<Ban>;
	createdAt: DateString;
	profile?: Profile;
	userStats?: UserStats;
}

export interface Profile {
	bio: string;
	socials: Socials;
}

export type Socials = {
	Discord?: string;
	Twitch?: string;
	YouTube?: string;
	Github?: string;
	Twitter?: string;
	Mastodon?: string;
	LinkedIn?: string;
	Instagram?: string;
	Spotify?: string;
	Patreon?: string;
	'Ko-fi'?: string;
	Paypal?: string;
};

export interface UserStats {
	cosXP: number;
	level: number;
	mapsCompleted: number;
	runsSubmitted: number;
	totalJumps: number;
	totalStrafes: number;
}

export interface Activity {
	id: number;
	userID: number;
	data: number;
	type: ActivityType;
	user?: User;
	createdAt: DateString;
	updatedAt: DateString;
}

export interface Notification {
	id: number;
	read: boolean;
	userID: number;
	user?: User;
	activityID: number;
	activity?: Activity;
	createdAt: DateString;
	updatedAt: DateString;
}

export interface Follow {
	followedID: number;
	followeeID: number;
	notifyOn: Flags<ActivityType>;
	followed?: User;
	followee?: User;
	createdAt: DateString;
}

export interface FollowStatus {
	local?: Follow;
	target?: Follow;
}

export interface MapSummary {
	status: MapStatus;
	statusCount: number;
}

//#endregion
//#region Auth

export interface JWTResponseWeb {
	accessToken: string;
	refreshToken: string;
	expiresIn: string;
}

export interface JWTResponseGame {
	token: string;
	length: number;
}

export interface RefreshToken {
	refreshToken: string;
}

//#endregion User
//#region Admin

export interface AdminActivity {
	id: number;
	comment: string | null;
	type: AdminActivityType;
	target: number;
	oldData: object;
	newData: object;
	userID: number;
	user?: User;
	createdAt: DateString;
}

export type Killswitches = Record<KillswitchType, boolean>;

//#endregion
//#region Reports

export interface Report {
	id: number;
	data: number;
	type: ReportType;
	category: ReportCategory;
	message: string;
	resolved: boolean;
	resolutionMessage?: string;
	submitterID: number;
	submitter: User;
	resolverID: number | null;
	resolver?: User;
	createdAt: DateString;
	updatedAt: DateString;
}

//#endregion
//#region Maps

export interface MMap {
	id: number;
	name: string;
	status: MapStatus;
	submitterID: number;
	createdAt: DateString;
	updatedAt: DateString;
	currentVersion: MapVersion;
	currentVersionID: string;
	versions: MapVersion[];
	info: MapInfo;
	submission: MapSubmission;
	submitter: User;
	images: MapImage[];
	thumbnail: MapImage;
	stats: MapStats;
	credits: MapCredit[];
	favorites: MapFavorite[];
	leaderboards: Leaderboard[];
	worldRecords: LeaderboardRun[];
	personalBests: LeaderboardRun[];
	testInvites?: MapTestInvite[];
}

export interface MapVersion {
	id: string;
	versionNum: number;
	submitterID: number | null;
	changelog: string;
	zones: MapZones;
	bspHash: string;
	zoneHash: string;
	downloadURL: string;
	vmfDownloadURL?: string;
	createdAt: DateString;
}

export interface MapInfo {
	description: string;
	youtubeID: string;
	creationDate: DateString;
	requiredGames: SteamGame[];
}

export interface MapCredit {
	type: MapCreditType;
	description: string | null;
	userID: number;
	user?: User;
	mapID: number;
	map?: MMap;
}

export interface MapFavorite {
	id: number;
	userID: number;
	user?: User;
	mapID: number;
	map?: MMap;
	createdAt: DateString;
}

export interface MapImage {
	id: string;
	small: string;
	medium: string;
	large: string;
	xl: string;
}

export interface MapListVersion {
	approved: number;
	approvedURL: string;
	submissions: number;
	submissionsURL: string;
}

export interface MapNotify {
	notifyOn: ActivityType;
	mapID: number;
	userID: number;
	createdAt: DateString;
	updatedAt: DateString;
}

export interface MapPreSignedUrl {
	url: string;
}

export interface MapReview {
	id: number;
	mainText: string;
	comments: MapReviewComment[];
	numComments: number;
	suggestions: MapReviewSuggestion[];
	editHistory: MapReviewEdit[];
	map: MMap;
	mapID: number;
	reviewerID: number;
	reviewer?: User;
	images: string[];
	resolved: boolean | null;
	resolverID: number;
	resolver?: User;
	createdAt: DateString;
	updatedAt: DateString;
}

export interface MapReviewComment {
	id: number;
	reviewID: number;
	text: string;
	reviewerID?: number;
	reviewer?: User;
	userID: number;
	user?: User;
	createdAt: DateString;
	updatedAt: DateString;
}

export interface MapReviewEdit {
	mainText?: string;
	resolved?: boolean | null;
	editorID: number;
	date: DateString;
}

export interface MapReviewSuggestion {
	gamemode: Gamemode;
	trackType: TrackType;
	trackNum: number;
	tier?: number;
	gameplayRating?: number;
	tags?: MapTag[];
}

export interface MapStats {
	reviews: number;
	downloads: number;
	subscriptions: number;
	plays: number;
	favorites: number;
	completions: number;
	uniqueCompletions: number;
	timePlayed: number;
}

export interface MapSubmission {
	type: MapSubmissionType;
	suggestions: MapSubmissionSuggestion[];
	placeholders: MapSubmissionPlaceholder[];
	dates: MapSubmissionDate[];
}

export interface MapSubmissionApproval {
	trackType: TrackType;
	trackNum: number;
	gamemode: Gamemode;
	tier?: number; // Hidden leaderboards don't have tiers
	type: Exclude<LeaderboardType, LeaderboardType.IN_SUBMISSION>;
	tags?: MapTag[];
}

export type MapSubmissionDate = {
	status: MapStatus;
	date: DateString;
};

export interface MapSubmissionPlaceholder {
	alias: string;
	type: MapCreditType;
	description?: string;
}

export interface MapSubmissionSuggestion {
	trackType: TrackType;
	trackNum: number;
	gamemode: Gamemode;
	tier: number;
	type: LeaderboardType.RANKED | LeaderboardType.UNRANKED;
	comment?: string;
	tags?: MapTag[];
}

export interface MapTestInvite {
	mapID: number;
	userID: number;
	user?: User;
	state: MapTestInviteState;
	createdAt: DateString;
	updatedAt: DateString;
}

//#endregion
//#region Map Zones

export interface MapZones {
	formatVersion: number;
	dataTimestamp: number;
	maxVelocity?: number;
	tracks: MapTracks;
	globalRegions?: GlobalRegions;
}

export interface GlobalRegions {
	bhop: Region[];
	cancel: Region[];
}

export interface MapTracks {
	main: MainTrack;
	bonuses?: BonusTrack[];
}

export interface MainTrack {
	zones: TrackZones;
	stagesEndAtStageStarts: boolean;
	bhopEnabled?: boolean;
}

export interface BonusTrack {
	zones?: TrackZones;
	defragModifiers?: number;
	bhopEnabled?: boolean;
}

export interface TrackZones {
	segments: Segment[];
	end: Zone;
}

export interface Segment {
	checkpoints: Zone[];
	cancel?: Zone[];
	name?: string;
	limitStartGroundSpeed: boolean;
	checkpointsRequired: boolean;
	checkpointsOrdered: boolean;
}

export interface Zone {
	regions: Region[];
	filtername?: string;
}

export interface Region {
	points: Vector2D[];
	bottom: number;
	height: number;
	teleDestTargetname?: string;
	teleDestPos?: Vector;
	teleDestYaw?: number;
	safeHeight?: number;
}

//#endregion
//#region Runs

export interface Leaderboard {
	gamemode: Gamemode;
	trackType: TrackType;
	trackNum: number;
	tier: number | null;
	style: Style;
	type: LeaderboardType;
	tags: MapTag[];
	linear: boolean;
}

export interface LeaderboardStats {
	leaderboard: Leaderboard;
	totalRuns: number;
}

export interface LeaderboardRun {
	gamemode: Gamemode;
	trackType: TrackType;
	trackNum: number;
	style: Style;
	time: number;
	downloadURL: string;
	replayHash: string;
	flags: Style[];
	splits?: RunSplits.Splits;
	rank: number;
	rankXP: number;
	userID: number;
	user?: User;
	mapID: number;
	map?: MMap;
	pastRunID: number;
	pastRun?: PastRun;
	leaderboard?: Leaderboard;
	createdAt: DateString;
}

export interface PastRun {
	id: number;
	gamemode: Gamemode;
	trackType: TrackType;
	trackNum: number;
	style: Style;
	time: number;
	flags: Style[];
	isPB: boolean;
	userID: number;
	user?: User;
	mapID: number;
	map?: MMap;
	leaderboardRun?: LeaderboardRun;
	createdAt: DateString;
}

export interface RunSession {
	id: number;
	mapID: number;
	gamemode: Gamemode;
	trackType: TrackType;
	trackNum: number;
	userID: number;
	createdAt: DateString;
}

export interface RunSessionTimestamp {
	id: number;
	majorNum: number;
	minorNum: number;
	time: number;
	sessionID: number;
	createdAt: DateString;
}

export namespace RunSplits {
	export interface Splits {
		trackStats: Stats;
		segments: Segment[];
	}

	export interface Segment {
		// Contains an entry for every subsegment the player has reached so far
		subsegments: Subsegment[];

		segmentStats: Stats;

		// This is velocity when effectively starting this segment (when *leaving* the
		// first zone)
		effectiveStartVelocity: vec3;

		// Whether this segment's checkpoints have a logical order. This lets split
		// comparison logic know if apparent gaps are due to skipped checkpoints
		// (align subsegments by minorNum) or are just unordered checkpoints (don't
		// align).
		checkpointsOrdered: boolean;
	}

	// A subsegment begins at the checkpoint zone with the specified minorNum (which
	// may be a Major Checkpoint zone, possibly the overall track start) and ends
	// when another checkpoint zone is activated (which may not be the next in
	// logical order if checkpoints can be skipped or done out of order).
	//
	// The very first subsegment of a run across all segments actually begins when
	// the run starts and so will have timeReached == 0.0. For all other
	// subsegments, timeReached has a meaningful value. Also note that for
	// subsegments after the first overall, stat tracking includes time spent within
	// its corresponding checkpoint zone.
	export interface Subsegment {
		minorNum: uint8;

		timeReached: float;

		// Velocity when triggering this checkpoint; note the difference between this
		// and Segment::effectiveStartVelocity
		velocityWhenReached: vec3;

		stats: Stats;
	}

	/** Stats for a whole run, or segment */
	export interface Stats {
		maxOverallSpeed: float;
		maxHorizontalSpeed: float;

		overallDistanceTravelled: float;
		horizontalDistanceTravelled: float;

		jumps: uint16;
		strafes: uint16;
	}
}

export interface XpGain {
	rankXP: number;
	cosXP: {
		gainLvl: number;
		oldXP: number;
		gainXP: number;
	};
}

export interface CompletedRun {
	isNewWorldRecord: boolean;
	isNewPersonalBest: boolean;
	run: LeaderboardRun;
	xp: XpGain;
}

//#endregion
//#region Misc

export interface TwitchStream {
	id: string;
	user_id: string;
	user_login: string;
	user_name: string;
	game_id: string;
	game_name: string;
	type: string;
	title: string;
	tags: string[];
	viewer_count: number;
	started_at: string;
	language: string;
	thumbnail_url: string;
	/** @deprecated */
	tag_ids: any[];
	is_mature: boolean;
}

export interface TwitchUser {
	id: string;
	login: string;
	display_name: string;
	type: string;
	broadcaster_type: string;
	description: string;
	profile_image_url: string;
	offline_image_url: string;
	/** @deprecated */
	view_count: number;
	email: string;
	created_at: string;
}

//#endregion

export interface PagedResponse<T> {
	totalCount: number;
	returnCount: number;
	data: T[];
}

export type ActivitiesGetQuery = PagedQuery & {
	userID?: number;
	type?: ActivityType;
	data?: number;
};

export type UpdateNotification = Pick<Notification, 'read'>;

export type AdminGetReportsExpand = ('submitter' | 'resolver')[];

export type AdminGetReportsQuery = PagedQuery & {
	expand?: AdminGetReportsExpand;
	resolved?: boolean;
};

export type AdminActivitiesGetQuery = PagedQuery & {
	filter?: AdminActivityType;
};

//#region Map

type BaseMapsGetAllExpand =
	| 'leaderboards'
	| 'info'
	| 'stats'
	| 'submitter'
	| 'currentVersionWithZones'
	| 'currentVersion'
	| 'versions'
	| 'versionsWithZones'
	| 'credits';

export type MapsGetAllExpand = Array<BaseMapsGetAllExpand | 'inFavorites' | 'personalBest' | 'worldRecord'>;

export type MapsGetAllSubmissionExpand = Array<
	BaseMapsGetAllExpand | 'inFavorites' | 'personalBest' | 'worldRecord' | 'reviews'
>;

type MapsGetAllBaseQuery = {
	skip?: number;
	take?: number;
	search?: string;
	searchStartsWith?: string;
	submitterID?: number;
};

export type MapsGetAllQuery = MapsGetAllBaseQuery & {
	expand?: MapsGetAllExpand;
	gamemode?: Gamemode;
	difficultyLow?: number;
	difficultyHigh?: number;
	linear?: boolean;
	favorite?: boolean;
	PB?: boolean;
};

export type MapsGetAllAdminFilter = Array<MapStatus>;

export type MapsGetAllAdminQuery = MapsGetAllBaseQuery & {
	filter?: MapsGetAllAdminFilter;
};

export type MapsGetAllSubmissionFilter = Array<
	MapStatus.PUBLIC_TESTING | MapStatus.PRIVATE_TESTING | MapStatus.CONTENT_APPROVAL | MapStatus.FINAL_APPROVAL
>;

export type MapsGetAllSubmissionQuery = MapsGetAllBaseQuery & {
	expand?: MapsGetAllSubmissionExpand;
	filter?: MapsGetAllSubmissionFilter;
};

export type MapsGetAllUserSubmissionQuery = Omit<MapsGetAllSubmissionQuery, 'submitterID'>;

export type MapsGetExpand = Array<MapsGetAllSubmissionExpand[number] | 'submission' | 'testInvites'>;

export type MapsGetQuery = { expand?: MapsGetExpand };

export interface CreateMapWithFiles {
	vmfs: File[];
	data: CreateMap;
}

export interface CreateMap extends Pick<MMap, 'name'> {
	submissionType: MapSubmissionType;
	suggestions: MapSubmissionSuggestion[];
	wantsPrivateTesting: boolean;
	placeholders: MapSubmissionPlaceholder[];
	testInvites?: number[];
	info: CreateMapInfo;
	zones: MapZones;
	credits: CreateMapCredit[];
	portingChangelog?: string;
}

export interface UpdateMap
	extends Partial<
		Pick<CreateMap, 'name' | 'suggestions' | 'placeholders' | 'testInvites' | 'credits' | 'submissionType'>
	> {
	status?: MapStatus.CONTENT_APPROVAL | MapStatus.FINAL_APPROVAL;
	info?: UpdateMapInfo;
	zones?: MapZones;
	portingChangelog?: string;
	resetLeaderboards?: boolean;
}

export interface UpdateMapAdmin extends Omit<UpdateMap, 'status'> {
	status?: MapStatus;
	finalLeaderboards?: MapSubmissionApproval[];
}

//#endregion
//#region Map Info

export type CreateMapInfo = Pick<MapInfo, 'description' | 'youtubeID' | 'creationDate' | 'requiredGames'>;

export type UpdateMapInfo = Partial<
	Pick<CreateMapInfo, 'description' | 'youtubeID' | 'creationDate' | 'requiredGames'>
>;

//#endregion
//#region Credits

export type MapCreditsGetExpand = 'user';

export type MapCreditsGetQuery = { expand?: MapCreditsGetExpand };

export type CreateMapCredit = Pick<MapCredit, 'userID' | 'type' | 'description'>;

//#endregion
//#region Images

export interface UpdateMapImages {
	imageIDs: string[];
}

export interface UpdateMapImagesWithFiles {
	images: File[];
	data: UpdateMapImages;
}

//#endregion
//#region Notifications

export type UpdateMapNotify = Pick<MapNotify, 'notifyOn'>;

//#endregion
//#region Runs

export type MapRunsGetExpand = 'splits';
export type MapRunsGetFilter = 'around' | 'friends';

export type MapLeaderboardGetQuery = PagedQuery & {
	gamemode: Gamemode;
	trackType?: TrackType; // Default 0
	trackNum?: number; // Default 1
	style?: Style; // Default 0
	expand?: MapRunsGetExpand;
	filter?: MapRunsGetFilter;
	userIDs?: number[];
	steamIDs?: string[];
	orderByDate?: boolean;
};

export type MapLeaderboardGetRunQuery = PagedQuery & {
	gamemode: Gamemode;
	trackType?: TrackType; // Default 0
	trackNum?: number; // Default 1
	style?: Style; // Default 0
	expand?: MapRunsGetExpand;
	userID?: number;
	rank?: number;
};

//#endregion
//#region Submissions

export interface CreateMapVersion extends Pick<MapVersion, 'changelog' | 'zones'> {
	resetLeaderboards?: boolean;
	hasBSP: boolean;
}

export interface CreateMapVersionWithFiles {
	vmfs: File[];
	data: CreateMapVersion;
}

//#endregion
//#region Reviews

export type MapReviewsGetExpand = ('map' | 'reviewer' | 'resolver')[];

export type MapReviewsGetQuery = PagedQuery & {
	official?: boolean;
	expand?: MapReviewsGetExpand;
	comments?: number;
};

export type MapReviewGetIdQuery = {
	expand?: string[];
};

type PickMapReview = Pick<MapReview, 'mainText'> & Partial<Pick<MapReview, 'suggestions'>>;

export interface CreateMapReview extends PickMapReview {
	needsResolving?: boolean;
}

export interface CreateMapReviewWithFiles {
	images?: File[];
	data: CreateMapReview;
}

export interface UpdateMapReview extends Partial<CreateMapReview> {
	resolved?: boolean | null;
}

export type AdminUpdateMapReview = Pick<UpdateMapReview, 'resolved'>;

export type CreateMapReviewComment = Pick<MapReviewComment, 'text'>;
export type UpdateMapReviewComment = CreateMapReviewComment;

//#endregion
//#region Test Invites

export interface CreateMapTestInvite {
	userIDs: number[];
}

export interface UpdateMapTestInvite {
	accept: boolean;
}

//#endregion

export enum Order {
	ASC = 'asc',
	DESC = 'desc'
}

export type PagedQuery = {
	skip?: number;
	take?: number;
};

// Only types work here, not interfaces.
// https://github.com/microsoft/TypeScript/issues/15300#issuecomment-332366024

export type QueryParam = {
	[param: string]: string | number | boolean | ReadonlyArray<string | number | boolean>;
};

export type QueryParamOptional = {
	[param: string]: string | number | boolean | ReadonlyArray<string | number | boolean> | undefined;
};

export type ReportGetExpand = ('submitter' | 'resolver')[];

export type ReportGetQuery = PagedQuery & {
	resolved?: boolean; // Note: this was a string on old API.
	expand?: ReportGetExpand;
};

export type CreateReport = Pick<Report, 'data' | 'type' | 'category' | 'message'>;

export type UpdateReport = Pick<Report, 'resolved' | 'resolutionMessage'>;

export type RunsGetAllExpand = Array<'user' | 'map' | 'leaderboardRun'>;
export enum RunsGetAllOrder {
	DATE = 'createdAt',
	RUN_TIME = 'time'
}

export type RunsGetAllQuery = PagedQuery & {
	expand?: RunsGetAllExpand;
	mapID?: number;
	mapName?: string;
	gamemode?: Gamemode;
	trackType?: TrackType; // Default 0
	trackNum?: number; // Default 1
	style?: Style; // Default 0
	flags?: number[];
	userID?: number;
	userIDs?: number[];
	isPB?: boolean;
	orderBy?: RunsGetAllOrder;
	order?: Order;
};

export type RunsGetExpand = RunsGetAllExpand;

export type RunsGetQuery = {
	expand?: RunsGetExpand;
};

export type CreateRunSession = Pick<RunSession, 'mapID' | 'gamemode' | 'trackType' | 'trackNum'>;

export interface UpdateRunSession {
	majorNum: number;
	minorNum: number;
	time: number;
}

export type CreateUser = Pick<User, 'alias'>;

export interface UpdateUser {
	alias?: string;
	bio?: string;
	socials?: Socials;
}

export interface AdminUpdateUser extends UpdateUser {
	roles?: Flags<Role>;
	bans?: Flags<Ban>;
}

export interface MergeUser {
	placeholderID: number;
	userID: number;
}

export type UsersGetExpand = Array<'profile' | 'userStats'>;

export type UsersGetQuery = {
	expand?: UsersGetExpand;
};

export type UsersGetAllExpand = UsersGetExpand;

export type UsersGetAllQuery = PagedQuery & {
	expand?: UsersGetAllExpand;
	search?: string;
	steamID?: string;
	steamIDs?: string[];
	userIDs?: number[];
};

export type UsersGetActivitiesQuery = Omit<ActivitiesGetQuery, 'userID'>;

export type UpdateFollowStatus = Pick<Follow, 'notifyOn'>;

export type UsersGetCreditsExpand = Array<'map' | 'info'>;

export type UsersGetCreditsQuery = PagedQuery & {
	expand?: UsersGetCreditsExpand;
};

type UserMapsBaseGetQuery = PagedQuery & { search?: string };

export type UserMapFavoritesGetExpand = Array<'info' | 'credits' | 'submitter' | 'personalBest'>;

export type UserMapFavoritesGetQuery = UserMapsBaseGetQuery & {
	expand?: UserMapFavoritesGetExpand;
};

export type DateString = string;

/**
 * Alias to distinguish a number supposed to represent a bit field.
 */
export type Flags<T extends number | undefined = undefined> = T extends void ? number : number & { __brand: T };

/**
 * Utility type to allow implementations of Prisma models to treat their `bigint` properties as `number`s.
 *
 * Excludes properties with key Exclude.
 *
 * Combined with NumberifyBigInt transformer to ensure we handle them safely.
 */
export type NumberifyBigInt<Model extends Record<string, any>, Exclude extends string | void = void> = {
	[K in keyof Model]: K extends Exclude
		? Model[K] // If excluded, do nothing
		: Model[K] extends bigint
			? number // Replace bigint with number
			: Model[K] extends bigint | null
				? number | null // Replace nullable bigint with nullable bigint
				: Model[K];
};

export type uint8 = number;
export type uint16 = number;
export type uint32 = number;
export type uint64 = bigint;
export type int8 = number;
export type int16 = number;
export type int32 = number;
export type int64 = bigint;

/**
 * Denotes a 32-bit IEEE floating point number, note all JS numbers are still
 * 64-bit (doubles) at runtime! Take care to use Math.fround when comparing.
 */
export type float = number;
export type double = number;

export type vec2 = { x: number; y: number };
export type vec3 = { x: number; y: number; z: number };

export type Vector = [number, number, number];
export type Vector2D = [number, number];
